<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2017%2F10%2F08%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型链构造函数，原型对象，实例关系：每个构造函数都有一个原型对象，原型对象对象包含指向构造函数的指针，每个实例都包含指向原型对象的内部指针。当把一个实例赋值给一个原型对象的时候，原型对象-》实例-》该实例的原型对象（从而获取该实例的属性方法），原型的查找顺序也是(原型对象-》实例-》该实例)从左向右查找的。1Sub.prototype = new sup(); 1 默认的原型为Object，因此每个对象都会有hasOwnProperty, isPropertyOf, toString等方法2 确定原型与实例的关系可以根据 instanceof Person.prototype.isPropertyOf(p1) 判断3 注意定义方法的顺序，给原型添加的方法一定要放在替换原型的语句之后4 原型链的问题：和原型一样，引用类型的数据会被所有实例共享。 借用构造函数（constructor stealing）借用构造函数就是通过call,apply的方式将另一个的构造函数当做自己的函数体function sup() {}function sub() { sup.call(this);}这种方式很少单独使用，无法避免构造函数模式存在的问题 特点可以在子类的构造函数中给超类的构造函数传递参数 组合继承组合继承 = 原型链 + 借用构造函数模式1234567function sup() &#123;&#125;function sub() &#123; sup.call(this);&#125;sub.prototype = new sup();sub.prototype.constructor = sub;... 融合了两种模式的优点，是最常用的继承模式 原型式继承1234567function object(o) &#123; // o必须为一个对象 function F() &#123;&#125;; F.prototype = o; return new F();&#125;// es5规范了原型式继承Object.create(o); 寄生式继承在原型式继承的基础上继续加工的结果12345function Test(o) &#123; var clone = object(o); clone.sayHi = function() &#123;&#125; return clone;&#125; 寄生组合继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。将sub.prototype = new sup()替换为了object(sup.prototype),省去了一次构造函数的调用（可是增加了new F() ..） 备注理解这些概念的时候本身就比较生硬，考虑问题的时候需要过滤掉一些干扰性的元素，考虑要考虑的问题本身。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 函数总结]]></title>
    <url>%2F2017%2F10%2F07%2Fes6-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[es6增加了很多语法糖，比如增加了一些方便判断的属性，写法上更加简单了 函数形参的默认值 形参默认值，即定义函数的时候可以给形参赋值，赋值的内容可以是常量，变量，表达式 需要注意的是： 1 默认值对arguments对象有影响 2 默认参数的临时死区 处理无命名参数 由于javascript函数的参数想传多少就传多少，之前会使用arguments对象处理无命名，现在可以使用...arg方式替代 注意 1 不定参后面不能有其他参数 2 不定参不能用于对象字面量setter中，因为setter中的参数有且只有一个 3 无论是否有不定参，arguments对象总是包含所有传入的参数 增强function构造函数 function构造函数，几乎没有用过… 12// 使用案例var add = new function(&apos;first&apos;, &apos;second=1&apos;, &apos;return first + second&apos;); 展开运算符 这是一个语法糖，嘿嘿，和不定参很像，不定参可以让各自独立的一些参数最终以数组的方式访问，展开运算的则是将数组打乱成各自独立的参数 1234567Math.max(25, 50, 70, 100);// 同样写法let val = [25, 50, 70, 100];Math.max(...val);也支持这种写法Math.max(...val, 101); name属性 Function.name, 方便开发者追踪栈记录 函数的多重用途用途 1 和new一起使用作为构造函数 内部调用[[Constructor]] 2 函数使用 内部调用[[Call]] 判断函数是否作为构造函数在使用 es5 p1 instanceof Person 但是无法区分是通过Person.call()还是new关键字得到的实例 es6 通过new.target来判断 当调用函数的[[Constructor]]方法时，会为new.target赋值new操作符的目标，通常为new时候的构造函数，如果函数调用的是[[Call]],new.target则为undefined // 通过new关键字创建 eg: typeof new.target !== “undefined” 块级函数 es5严格模式下，在代码块中声明函数会报异常，而在es6中作为一个块级声明（严格模式），在作用域内可以使用，一旦代码块执行完毕后，函数也结束了，非严格模式下会被提升至外围函数或者全局作用域中 块级函数与let函数表达式类似，区别为块级函数会被提升至块的顶部，let 函数表达式不会 箭头函数 箭头函数很像c#中的lambda表达式 特点 1 没有 this, super, arguments, new.target的绑定，这些都由外围最近一层的非箭头函数决定 2 不能通过new关键字调用 3 没有原型 4 不可改变this的绑定 5 不支持arguments对象 6 不支持重复的命名参数 语法 12345678910111213141516171819let doNothing = () =&gt; &#123;&#125;; // 创建空函数let getName = () =&gt; Nicholas;// 无参let reflect = value =&gt; value;// 一个参数let sum = (num1, num2) =&gt; num1+mum2; // 多个参数，一个表达式的函数体let sum = (num1, num2) =&gt; &#123; // 多个参数，由多个表达式组成的函数体 return num1+mum2;&#125;;// 如果返回结果是对象，需要将该字面量包在`()`中,这样是为了与函数体区分let getTempItem = id =&gt; (&#123;id: id, name: &apos;temp&apos;&#125;);//创建立即执行函数let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; return name; &#125; &#125;&#125;)(&apos;Nicholas&apos;); 其它 1 简化sort,map,reduce的写法，eg: values.sort((a, b) =&gt; a-b) 2 在箭头函数上调用apply, call, bind和普通函数类似，只是箭头函数中的this不会受这些方法的影响 尾调用优化 系统引擎优化 123function a() &#123; return b(); // 尾调用&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局: 元素的摆放方式displaypositionfloatflex display 实现同行显示或者换行显示 block（p, h1, ul, form） 和margin: 0 auto 组合使用，居中显示 inline(span, a, label) inline-block(input, textarea, select, button) 和inline比起来，内容换行后占据宽度剩下的空间 和 vertical-align: middle 实现垂直居中 none display: none VS visibility: hidden visibility 元素仅仅是隐藏，占据原来的空间 position 定位top, bottom, left, right, z-index同时设置top, bottom, left, right会将元素撑开 z-index 栈, 因此z-index大的不一定就显示在上面 static|relative|absolute|fixed relative仍在文档流中参照物为元素本身 absolute默认宽度为内容宽度脱离文档流参照物为第一个定位祖先/视窗（包含块/初始包含块–padding-edge）https://segmentfault.com/a/1190000009661604 fixed默认宽度为内容宽度脱离文档流参照物为视窗 ios中会存在一些问题，存在原因？解决方式？问题，解决方案iscroll库引入动态改变position的值，改为static floatleft right none默认宽度为内容宽度半脱离文档流（对元素，托利文档流，对内容，在文档流）会向指定方向一直移动 clear [both|left:right|none|inherit]应用于后续元素应用块级元素清除浮动的方法：增加空白元素，设置class{display: block; clear: both; }在浮动元素的父元素添加clearfix.clearfix:after { content: ‘.’; display: block; clear: both; height: 0; overflow: hidden; visibility: hidden;} flexflex-grow: 拉伸flex-shrink: 收缩 其它实现左右布局的方式absolute+margin-leftfix+margin-leftfloatflex 顶部固定，底部固定布局position: fixed固定，使用padding-bottom和padding-top控制上下间距。 走马观花的耕了一遍..感觉没有多少成就感，呜呜 ~~(&gt;_&lt;)~~ 以后有收获再来升级这篇文章吧..]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象描述： 无序的key,value键值对 整个对象发展的过程： ——》先是有个new一个对象的写法 简化写法 ——》对象字面量（可以使用对象写法） 批量生产 ——》工厂模式（new Object） 区别自定义对象类型 ——》构造函数类型（可以new 自定义类型, 构造函数定义来了） 解决函数类型实例化造成的空间浪费 ——》原型模式（出现原型对象） 原型对象为实例共享，引用类型修改时会对其它实例造成影响 ——》组合使用构造函数原型模式（1+1 = ？） … 一系列的相关的问题 this指向，改变this指向的途径，作用域，识别实例来自哪个构造函数，对象看成一个key,value列表因此出现元素遍历,区别实例属性原型链属相-&gt;for in-&gt;.. 创建自定义对象 对象字面量 123456789var person = &#123; name: &apos;aa&apos;, age: 18&#125;Object实例创建var person = new Object();person.name = &apos;aa&apos;;person.age = 18; 属性 数据属性 访问器属性： 封装一些组件时一些高级用法时使用 工厂模式 123456function createPerson(name, age) &#123; var o = new Object(); o.name = name; o.age = age; return o;&#125; 解决构造函数或者对象字面量重复的问题，就好比一个蛋糕模子，每次创造出一模一样的东西，缺点：无法区别这些蛋糕（没有解决对象的识别问题） 构造函数模式 与工厂模式比较有点是可以将实例识别为某一种特定的类型 为了区别构造函数和普通函数构造函数首字符大写，构造函数本质就是普通函数，当使用关键字new的时候会产生神奇的变化 1 创建新对象 2 将构造函数的作用域赋值给新对象（this指向改变） 3 执行构造函数的代码（为新对象添加属性） 4 返回新对象 123456function Person(name, age) &#123; this.name = name; this.age = age; console.log(1);&#125;var p1 = new Person(); 缺点：属性为function类型时，多次创建实例的同时也会创建多个function实例 原型模式 原型模式需要理清 构造函数，实例，原型对象之间的关系 1 理解原型对象 每个函数都有prototype属性，存储了原型对象。创建原型对象后会自动获取constructor属相，其余属性都是从Object上继承而来 方法： 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = &apos;name&apos;;Person.prototype.age = &apos;agePro&apos;;var person1 = new Person();person1.age = &apos;age&apos;;Person.prototype.isPrototypeOf(person1)// true;// 返回原型链上的值Object.getPrototypeOf(person1);// 使用delete可以删除实例属性，那么就可以正常获取原型属性了delete person1.age// hasOwnProperty,判断属相是否为实例属性person1.hasOwnProperty(&apos;age&apos;) //boolean 原型与in操作符 in 两种使用方式 单独使用/ for in 循环 for in循环可以遍历可枚举的属性，因此位于原型或者实例的都可以扫描到 in 使用 1234567891011&quot;age&quot; in person1// 判断属相属于实例还是原型：function hasPrototypePropertype(obj, name) &#123; return !obj.hasOwnProperty(name) &amp;&amp; (name in obj);&#125;// Object添加keys()属性，返回所有可枚举的属性（字符串数组）Object.keys(person1)// 返回所有属性，包括不可以枚举属性Object.getOwnPropertyNames(person1)Object.getOwnPropertyNames(Person.prototype) 更简单的原型语法 123456789function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 需要添加这个，否则constructor指针将不指向person，重新设置constructor属性会导致该属性标记为可枚举类型，不过可以重新定义为definePropoty(Person.prototype, &apos;constructor&apos;, &#123; enumerable: false, value: Person &#125;) name: &apos;name&apos;, age: &apos;age&apos;&#125; 原型的动态性 1234567891011121314function Person() &#123;&#125;var p2 = new Person();Person.prototype = &#123; constructor: Person, name: &apos;name&apos;, age: &apos;age&apos;&#125;p2.age // undefinedfunction Person() &#123;&#125;var person1 = new Person();Person.prototype.name = &apos;name&apos;;Person.prototype.age = &apos;agePro&apos;;person1.age; // agePro 原生对象的原型 所有原生的引用类型都是通过原型模式创建的，他们都在构造函数的原型上添加了方法，因此可以给这些原生对象添加原型属性，这样不好，， 原型对象的问题 实例可以更改引用类型的属性，导致其他的实例受影响 组合使用构造函数原型模式 没啥好说的，结合了两种模式的优点，是使用最广泛的模式了 问题 操作符 in typeof instanceof delete Object 好神奇 Function.prototype.[call|aplly|bind|isGenerator|toSource|toString] bind：改变this指向，不执行函数体，返回改变this后的函数引用 call,apply: 改变this指向，执行函数体，返回执行结果 12345678910111213141516this.x=10;var obj = &#123; x: 100, num: function(desc) &#123; console.log(desc+this.x) &#125;&#125;obj.x; // 100obj.num(&apos;d&apos;); // 100var b = obj.num;// 此刻的this为函数的this，指向全局b(&apos;e&apos;); // 10var b2 = b.bind(obj,&apos;a&apos;);b2(&apos;f&apos;); // 100var b3 = b.call(obj, &apos;b&apos;) // 100var b3 = b.apply(obj, [&apos;c&apos;]) // 100 this指向 new一个对象都做了什么 constructor属性指向构造函数,作用？ https://segmentfault.com/q/1010000000347868 函数作用域，函数的this指向 作用域（函数作用域，全局作用域，es6块作用域） 好像没有删除原型属性的方法 参考网站]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F09%2F29%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[总结选择器感觉就是像在记流水账，，，不过css的选择器功能确实挺强大的，有些匹配和正则的匹配方式是一致的，有些是css3新增的，旧版本的浏览器可能会不支持，可以通过caniuse网站来查看兼容性。 详细脑图 css历史 css1 1996 css2 1992 css2.1 2007 css3 2001-. 外部文件引入方式 &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot;&gt;&lt;/link&gt; 浏览器私有属性 chrome，safari -webkit- firefox -moz- IE -ms- opera -o- 语法 注释 /**/ 选择器 { 属性声明 } 属性声明=属性名：属性值 属性值语法： margin:[||auto]{1,4} 基本元素 组合符号 数量符号 基本类型 关键字, 类型, 符号（/,）, inherit, initial 组合符号 空格（必填，顺序有关） &amp;&amp;（必填，顺序无关，） ||（至少出现一个） | （只能出现一个） [] 分组 数量符号 无 + 可以出现一次货多次 ? 可出现也可以不出现 {2,4} * # 一次或者多次 规则语法 @标示符 xxx; @ 标示符 {} 规则 @media @keyframes @font-face @import 选择器 ID选择器 类选择器 标签选择器 *通配符选择器 属性选择器 12345678[attr][attr=&quot;val&quot;] 表示val中包含符号或者空格[attr=val] #nav&#123;&#125; == [id=nav]&#123;&#125;[attr~=val] .sport&#123;&#125; == [class~=sports]&#123;&#125;，可用于除了class以为的其它属性[attr|=val] 特定属性选择器，一般用于匹配属性lang的值[attr^=val][attr$=val][attr*=val] 伪类选择器 1234567891011121314151617181920a:linka:visiteda:hovera:active:enabled, disabled, checked:only-child:first-child:last-child:nth-child(even|odd):nth-child(n+1):nth-last-child(n+1)dd:first-of-type&#123;&#125;(同上):empty:root:not eg: :not(p)选择非p元素:target:lang() 伪元素选择器 123456(应用在元素内容的选择器)在css3中为了区别伪元素和伪类在前面添加::::first-letter::first-line::before (和content一起使用)::after::selection 组合选择器 1234567后代选择器.main h2子选择权.main&gt;h12兄弟选择器h2+p(获取前面为h2的一个p元素)h2~p(获取前面为h2的所有兄弟) 选择器分组 h1,h2,h3... css优先级 !important a = 行内样式 1000 b = ID选择器的数量 100 c = 类、属性选择器的数量 10 d = 标签选择器和伪元素选择器的数据量 1 兼容性测试网站 https://www.quirksmode.org/css/ http://caniuse.com/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国金项目总结]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%9B%BD%E9%87%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node地址转发 方案一种使用由于请求地址不同源存在跨域问题，因此使用使用node地址进行了一次转发 123456789101112131415161718192021222324'use strict';const path = require('path');const express = require('express');const proxy = require('express-http-proxy');const proxyUrl = 'https://webapps.yongjinbao.com.cn';const app = express();app.use(express.static(__dirname));app.use('/api', proxy(proxyUrl, &#123; // 当访问含有/api的地址时做转发处理 proxyReqPathResolver: (req) =&gt; &#123; return require('url').parse(req.url).path; &#125;&#125;));app.use('*', function (req, res)&#123;// 项目启动后加载的页面 res.sendFile(path.resolve(__dirname, 'fund.html'));&#125;);app.listen(8880, () =&gt; &#123; console.log('App is running on port 8880');&#125;); 数据逻辑处理（同步以及异步处理） 方案二，由于客户端不能对接口进行转发，数据仅存在服务器的静态文件中，使用了一种类似于jsonp的请求方式，但不是jsonp,即在静态文件中将所有的数据放在一个变量中。前端通过动态的add &lt;script&gt;标签的方式获取在静态文件中定义的变量取值。数据分四次获取，每个文件50条，滚动分页的方式加载数据，每次加载10条实现思路将异步和同步数据的处理逻辑分开写。可能遇到的滚动时获取异步数据时可能取不到，需要添加一个flag标志，当数据获取以后再去做数据渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 动态加载scriptfunction loadScript(url,callback) &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.async = 'async'; script.src = url; document.body.appendChild(script); script.onload = function()&#123; callback(); &#125;&#125;// 分情况加载数据function getNews(news_page_num, page_num, isGetScript) &#123; newsLoading = false; var newsData = []; if (isGetScript) &#123; loadScript('https://devtest.yjbtest.com/gjzqwxtest3g/information/data/newsData'+news_page_num+'.json', function() &#123; newsLoading = true; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; renderNews(newsData.slice(0,10)); &#125;); &#125; else &#123; newsLoading = true; var data = []; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; switch (page_num%5) &#123; case 2: data = newsData.slice(10,20); break; case 3: data = newsData.slice(20,30); break; case 4: data = newsData.slice(30,40); break; case 0: data = newsData.slice(40,50); break; &#125; renderNews(data); &#125;&#125; 无限滚动 监听window的scroll事件，在页面的底部放一个loading的div，当滚动事件触发的时候判断loading div据顶部高度是否小于当前文档的高度，如果小于那么loading div就已经展示在页面中了，那么去进行数据获取防止数据请求过于频繁添加了一个定时器在页面数据加载完成的时候移除滚动事件 123456789101112131415161718192021222324252627282930313233window.addEventListener('scroll', scrollLoad, false);function scrollLoad() &#123; if (scrollTimer) &#123; setTimeout(scrollTimer); &#125; scrollTimer = setTimeout(function()&#123; var loadingDom = document.querySelector('.scroll-stance-element'); var loadingDomTop = loadingDom.getBoundingClientRect().top; var windowHeight = window.innerHeight; if (loadingDomTop &amp;&amp; loadingDomTop &lt; windowHeight) &#123; if ($('.new-con-tpl .block').length &lt; 200) &#123; if (!newsLoading) &#123; return; &#125; if (pageNum%5 == 0) &#123; newsPageNum++; &#125; pageNum++; if (pageNum%5 == 1) &#123; getNews(newsPageNum, pageNum, true); &#125; else &#123; getNews(newsPageNum, pageNum); &#125; &#125; else &#123; $('.scroll-stance-element').addClass('hidden'); $('.new-nomore').removeClass('hidden'); window.removeEventListener('scroll', scrollLoad, false); &#125; &#125; &#125;, 100);&#125; 根据屏幕宽度对字符串动态进行截取 截取字符串计算文档的宽度获取当前的字号计算当前可以容纳的字数 进入其他项目咨询页面配置页面路由 由于需要跳转至另一个framework7项目中，因此配置了相关的进入页面的路由 1234567// 获取url里的信息function getQueryValue(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null)return unescape(r[2]); return null;&#125; jsonp和直接引入静态js文件(理解jsonp)本次中由于只有静态文件，本次以引入文件的方式，在文件加载完成的时候获取约定的变量的方式获取和引入本地文件一样的道理比较通俗易懂的方式理解jsonp: http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 其它文档加载的两个函数DOMContentLoaded， load 在chrome network面板中可以很清新的看到DOMContentLoaded页面基本结构加载完成后显示完成时间。和jquery中的$(function(){})一致当初始HTML文档已完全加载和解析时，将触发DOMContentLoaded事件，而无需等待样式表，图像和子框架完成加载。——MDNhttps://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded 1234567document.addEventListener("DOMContentLoaded", function() &#123; // ...代码...&#125;, false);// DOMContentLoaded$(document).ready(function() &#123; // ...代码...&#125;); load页面完全加载显示完成时间 当一个资源及其依赖资源已完成加载时，将触发load事件。 ——MDN 123456window.addEventListener("load", function() &#123; // ...代码...&#125;, false);$(document).load(function() &#123; // ...代码...&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型，原型链笔记]]></title>
    <url>%2F2017%2F06%2F30%2F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解原型，原型链需要了解 原型对象 构造函数 实例三者之间的关系 原型 每个对象(Person)都会有一个原型对象，对象的实例(p1)包含一个隐式的指针指向原型对象 p1.propo === Person.prototype 原型链 如图所示 存在一个对象Student，想拥有Person的一些属性和方法，那么Student.proportype = new Person();那么new Student（）的实例就会存在Student 存在一个隐士指针指向Student的原型对象，而Student的原型指向了person的原型，由于所有自定义对象都是从Object对象继承来的，那么person的原型有指向了Object的原型 总结（摘自红宝书，第6章） 1 原型链之间为引用关系，因此对象实例共享所有的属性和方法，在原型链中的引用类型，因此不适宜单独使用，解决这个问题是利用构造函数，在子类构造函数的内部调用超类的构造函数(Person.call(this, name,,))，这样可以做到每个实例都具有自己的属性，同时还能保证只是用构造函数模式来定义类型。 2 对象可以在编码执行过程中创建和增强，因此具有动态性而非严格定义的实体。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function f() &#123;&#125;; f.prototype = o; return new f();&#125;function inher(sub,sup)&#123; var prototype = object(sup.prototype); // 创建对象 prototype.constructor = sub; // 增强对象 sub.prototype = prototype; // 指定对象&#125;function sup(name) &#123; this.name = name; this.color = ['blue','red']&#125;sup.prototype.sayName = function() &#123; console.log(this.name)&#125;function sub(name,age) &#123; sup.call(this, name); this.age = age;&#125; inher(sub,sup);sub.prototype.sayAge = function() &#123; console.log(this.age);&#125;var s1 = new sub() 其它一个不错的在线编辑绘制图片工具：processon在问答网站回答问题可以促使去各处查资料，优化表达，学习更全面的知识]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现列表标题标题头第一列最后一列固定]]></title>
    <url>%2F2017%2F05%2F24%2F%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E6%A0%87%E9%A2%98%E6%A0%87%E9%A2%98%E5%A4%B4%E7%AC%AC%E4%B8%80%E5%88%97%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%97%E5%9B%BA%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[实现列表标题标题头第一列最后一列固定 实现思路：创建三个div，布局为左中右，其中每个div中设置为上下结构（上为列表的表头，下为数据部分）左右：{overflow：hide, 宽度：固定值， 高度：根绝文档设置高度}中间：{overflow：auto, 宽度：文档宽度-左右宽度， 高度：根绝文档设置高度}js代码处理：上下滚动，左右的div scrollTop和当前滚动的divscrollTop, 左右滚动同理 代码：html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script type="text/template7" id="container-fluid-tpl"&gt; &lt;div class="left_div"&gt; &lt;div class="left_div1"&gt; &lt;table class="left_table1"&gt; &lt;tr&gt; &lt;th&gt;基金名称&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="left_div2"&gt; &lt;table class="left_table2"&gt; &#123;&#123;#each dataLeft&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="name &#123;&#123;font&#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class="code"&gt;&#123;&#123;code&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div"&gt; &lt;div class="data_div1"&gt; &lt;div class="data_divx"&gt; &lt;table class="data_table1"&gt; &lt;tr&gt; &lt;th&gt;认/申购费率&lt;/th&gt; &lt;th class="active"&gt;日涨幅&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1周&lt;i class="iconfont icon-arrow-down2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近3月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近6月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;今年以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近一年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近三年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;成立以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div2"&gt; &lt;table class="data_table2"&gt; &#123;&#123;#each dataCenter&#125;&#125; &lt;tr&gt; &lt;td&gt; &lt;div class="&#123;&#123;center1.status11&#125;&#125;"&gt;&#123;&#123;center1.center11&#125;&#125;&lt;/div&gt; &lt;div class="&#123;&#123;center1.status12&#125;&#125;"&gt;&#123;&#123;center1.center12&#125;&#125;&lt;/div&gt; &lt;/td&gt; &lt;td class="&#123;&#123;center2.status&#125;&#125;"&gt;&#123;&#123;center2.center2&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center3&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center4&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center5&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center6&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center7&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center8&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center9&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center10&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="right_div"&gt; &lt;div class="right_div1"&gt; &lt;table class="right_table1"&gt; &lt;tr&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="right_div2"&gt; &lt;table class="right_table2"&gt; &#123;&#123;#each dataRight&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="buy-btn"&gt;&#123;&#123;this&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135.container-fluid &#123; table &#123; width: 100%; max-width: 100%; margin-bottom: 20px; &#125; .red &#123; color: #ff0000; &#125; .green &#123; color: #1bc01b; &#125; .gray &#123; color: #a3a3a3; &#125; .tlt&#123; color: #a3a3a3; text-decoration: line-through; &#125;&#125;.left_table1 th, .data_table1 th, .right_table1 th &#123; font-size: 13px; font-weight: 500; color: #686868; text-align: center; background: #F0F1F3; padding: 7px 0;&#125;.left_table2 th, .data_table2 td, .right_table2 th &#123; word-break: break-all; font-size: 15px; font-weight: 500; text-align: center; background: #fff; border-bottom: 1px solid #efeff4; height: 90px; .fs15 &#123; font-size: 15px; &#125; .fs13 &#123; font-size: 13px; &#125; &#125;.left_div&#123; width:120px; float: left; .left_div1&#123; width: 100%; &#125; .left_div2&#123; margin-top:-20px; width: 100%; overflow: hidden; &#125; .left_table1 th &#123; text-align: left; padding-left: 16px; &#125; .left_table2 th &#123; text-align: left; padding-left: 16px; .name &#123; color: #424647; &#125; .code &#123; font-size: 13px; color: #888; &#125; &#125;&#125;.right_div&#123; width:80px; float: left; .right_div1&#123; width: 100%; &#125; .right_div2&#123; margin-top:-20px; width: 100%; // height: 72vh; overflow: hidden; &#125; .right_table2 .buy-btn&#123; font-size: 14px; color: #fff; background: #e15b54; display: inline-block; width: 60px; height: 24px; line-height: 24px; border-radius: 2px; &#125;&#125;.data_div&#123; float: left; .data_div1&#123; width: 100%; overflow: auto; &#125; .data_divx&#123; width: 900px; &#125; .data_div2&#123; margin-top:-20px; width:100%; // height:72vh; overflow: auto; -webkit-overflow-scrolling: auto; // -webkit-overflow-scrolling: touch; &#125; .data_table1&#123; width: 880px; .iconfont &#123; font-size: 12px; &#125; th.active&#123; color: #e15b54; &#125; &#125; .data_table2&#123; /**width和max-width一起写，手机浏览器打开也能固定长度**/ width: 880px; max-width: 880px; white-space:nowrap; &#125; .data_table1 th&#123; width:10%; &#125; .data_table2 td&#123; width:10%; &#125;&#125; js1234567891011121314151617181920212223242526function createTab(selector, data) &#123; var template = $$('#container-fluid-tpl').html(); var complieTemplate = Template7.compile(template); var renderTemplate = complieTemplate(data); $$(selector+' .container-fluid').html(renderTemplate); var right_div2 = document.querySelector(selector+' .data_div2'); var data_div1 = document.querySelector(selector+' .data_div1'); right_div2.onscroll = function()&#123; var right_div2_top = this.scrollTop; var right_div2_left = this.scrollLeft; document.querySelector(selector+' .left_div2').scrollTop = right_div2_top; document.querySelector(selector+' .right_div2').scrollTop = right_div2_top; document.querySelector(selector+' .data_div1').scrollLeft = right_div2_left; &#125; data_div1.onscroll = function()&#123; var data_div1_left = this.scrollLeft; document.querySelector(selector+' .data_div2').scrollLeft = data_div1_left; &#125; //设置右边div宽度 var tabHeight = $$('body').height()-$$('.navbar').height()-$$('.tab-nav').height()-$$(selector+' .data_divx').height() document.querySelector(selector+' .data_div').style.width=""+$$('body').width()-200+"px"; document.querySelector(selector+' .left_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .data_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .right_div2').style.height=tabHeight+"px"; &#125; 问题&amp;总结1 苹果手机出现滚动条时会有橡皮条效果通过-webkit-overflow-scrolling设置 -webkit-overflow-scrolling: auto; // 橡皮条效果，滚动速度较慢 -webkit-overflow-scrolling: touch; // 默认效果 2 横向滚动条scroll事件频繁触发，（网页中）页面显示会有些错位。（待优化）。3 元素距离参考图片 offset- offsetWidth(包含padding、border、不包含margin) offsetHeight(同上) offsetLeft(返回元素的x坐标，相对于offsetParent；如果offsetParent为null,则返回对应的文档坐标) offsetTop(同上,返回元素的y坐标) offsetParent(返回最近的包含该元素的定位元素) client- clientWidth(不包含border、margin、滚动条) clientHeight(同上) clientLeft(相当于border-left-width,属性设置元素的左边框的宽度。) clientTop(相当于border-top-width) scroll- scrollWidth(不包含border、margin，返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）, scrollWidth的值要大于clientWidth。) scroHeight(同上) scrollLeft(可读写，获取或设置元素滚动条的位置) scrollTop(同上)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ学习1]]></title>
    <url>%2F2017%2F05%2F15%2FJQ%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[jq结构1234567(function( window, undefined ) &#123; // If there is a window object, that at least has a document property, // define jQuery and $ identifiers if ( typeof window === "object" &amp;&amp; typeof window.document === "object" ) &#123; window.jQuery = window.$ = jQuery; &#125;&#125;)( window ); 传入window对象时防止压缩时window被处理为普通变量undefined在一些浏览器中可以对undefined进行修改 JQ对象上的属性和方法1234567891011121314jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context, rootjQuery );&#125;jquery.fn = jquery.prototype = &#123; jquery: 版本, constructor: 修正指针指向问题, init: 初始化和参数管理, selector: 存储选择字符串, length: this对象的长度, toArray: 传数组, ...&#125;jQuery.fn.init.prototype = jQuery.fn; 参考文章 init方法123456789101112131415jQuery.fn = jQuery.prototype = &#123; init: function() &#123; $(""), $(null), $(undefined), $(false) $('#div1') $('.box') $('div') $('#div1 div.box') $('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $(this) $(document) $(function()&#123;&#125;) $([]) $(&#123;&#125;) return jQuery.makeArray( selector, this ); &#125;&#125; 备注：1 constructor以字面量的方式定义对象，需要指定当前的constructor2 prototype, constructor, 面向对象概念理解]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习笔记]]></title>
    <url>%2F2017%2F05%2F03%2Fcanvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简单例子123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="application/javascript"&gt; function draw() &#123; var canvas = document.getElementById("canvas"); if (canvas.getContext) &#123; var ctx = canvas.getContext("2d"); ctx.fillStyle = "rgb(200,0,0)"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = "rgba(0, 0, 200, 0.5)"; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="draw();"&gt; &lt;canvas id="canvas" width="150" height="150"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 直接可以绘制图形的方法fillRect(x, y, width, height)绘制一个填充的矩形strokeRect(x, y, width, height)绘制一个矩形的边框clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。 绘制基本图形，文本，图片，变换translate(x, y)translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。fillStyle = color设置图形的填充颜色。strokeStyle = color设置图形轮廓的颜色。globalAlpha = transparencyValue这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。lineWidth = value设置线条宽度。lineCap = type设置线条末端样式。shadowOffsetX = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowOffsetY = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowBlur = float shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。shadowColor = color shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。 绘制路径beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。closePath()闭合路径之后图形绘制命令又重新指向到上下文中。当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。stroke()通过线条来绘制图形轮廓。fill()通过填充路径的内容区域生成实心的图形moveTo(x, y)将笔触移动到指定的坐标x以及y上。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。lineTo(x, y)绘制一条从当前位置到指定x以及y位置的直线。arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。quadraticCurveTo(cp1x, cp1y, x, y)绘制贝塞尔曲线，cp1x,cp1y为控制点，x,y为结束点。rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。save()restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 推荐基于canvas小游戏 基于canvas的小游戏 详细canvas APIMDNcanvas API]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build-blog]]></title>
    <url>%2F2017%2F05%2F03%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start导入hexo1$ npm install -g hexo-cli --registry=https://registry.npm.taobao.org 初始化项目1$ hexo init Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites123456789$ hexo deploy// 报错:ERROR Deployer not found: githubnpm install hexo-deployer-git --savedeploy: type: git // 或者github repository: git@github.com:lvSally/lvSally.github.io.git branch: master 其它1 使用hexo new page tags/categories 创建分类或标签2 在themes _config.yml 控制主体显示3 themes -&gt; _config.yml -&gt; baidu_analytics 添加百度统计id可添加百度统计功能4 themes -&gt; _config.yml -&gt; avatar 设置头像5 next第三方服务集成6 网易云跟帖 悲剧的是类似github.io的子域名基本信息填写不能通过7 Disqus,最终选择了Disqus，缺点是需要翻墙，使用Disqus比较简单，注册一个账号，在主题的设置文件中添加以下shortname即可。More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>