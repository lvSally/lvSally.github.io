<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F09%2F29%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[总结选择器感觉就是像在记流水账，，，不过css的选择器功能确实挺强大的，有些匹配和正则的匹配方式是一致的，有些是css3新增的，旧版本的浏览器可能会不支持，可以通过caniuse网站来查看兼容性。 详细脑图 css历史 css1 1996 css2 1992 css2.1 2007 css3 2001-. 外部文件引入方式 &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot;&gt;&lt;/link&gt; 浏览器私有属性 chrome，safari -webkit- firefox -moz- IE -ms- opera -o- 语法 注释 /**/ 选择器 { 属性声明 } 属性声明=属性名：属性值 属性值语法： margin:[||auto]{1,4} 基本元素 组合符号 数量符号 基本类型 关键字, 类型, 符号（/,）, inherit, initial 组合符号 空格（必填，顺序有关） &amp;&amp;（必填，顺序无关，） ||（至少出现一个） | （只能出现一个） [] 分组 数量符号 无 + 可以出现一次货多次 ? 可出现也可以不出现 {2,4} * # 一次或者多次 规则语法 @标示符 xxx; @ 标示符 {} 规则 @media @keyframes @font-face @import 选择器 ID选择器 类选择器 标签选择器 *通配符选择器 属性选择器 12345678[attr][attr=&quot;val&quot;] 表示val中包含符号或者空格[attr=val] #nav&#123;&#125; == [id=nav]&#123;&#125;[attr~=val] .sport&#123;&#125; == [class~=sports]&#123;&#125;，可用于除了class以为的其它属性[attr|=val] 特定属性选择器，一般用于匹配属性lang的值[attr^=val][attr$=val][attr*=val] 伪类选择器 1234567891011121314151617181920a:linka:visiteda:hovera:active:enabled, disabled, checked:only-child:first-child:last-child:nth-child(even|odd):nth-child(n+1):nth-last-child(n+1)dd:first-of-type&#123;&#125;(同上):empty:root:not eg: :not(p)选择非p元素:target:lang() 伪元素选择器 123456(应用在元素内容的选择器)在css3中为了区别伪元素和伪类在前面添加::::first-letter::first-line::before (和content一起使用)::after::selection 组合选择器 1234567后代选择器.main h2子选择权.main&gt;h12兄弟选择器h2+p(获取前面为h2的一个p元素)h2~p(获取前面为h2的所有兄弟) 选择器分组 h1,h2,h3... css优先级 !important a = 行内样式 1000 b = ID选择器的数量 100 c = 类、属性选择器的数量 10 d = 标签选择器和伪元素选择器的数据量 1 兼容性测试网站 https://www.quirksmode.org/css/ http://caniuse.com/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国金项目总结]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%9B%BD%E9%87%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node地址转发 方案一种使用由于请求地址不同源存在跨域问题，因此使用使用node地址进行了一次转发 123456789101112131415161718192021222324'use strict';const path = require('path');const express = require('express');const proxy = require('express-http-proxy');const proxyUrl = 'https://webapps.yongjinbao.com.cn';const app = express();app.use(express.static(__dirname));app.use('/api', proxy(proxyUrl, &#123; // 当访问含有/api的地址时做转发处理 proxyReqPathResolver: (req) =&gt; &#123; return require('url').parse(req.url).path; &#125;&#125;));app.use('*', function (req, res)&#123;// 项目启动后加载的页面 res.sendFile(path.resolve(__dirname, 'fund.html'));&#125;);app.listen(8880, () =&gt; &#123; console.log('App is running on port 8880');&#125;); 数据逻辑处理（同步以及异步处理） 方案二，由于客户端不能对接口进行转发，数据仅存在服务器的静态文件中，使用了一种类似于jsonp的请求方式，但不是jsonp,即在静态文件中将所有的数据放在一个变量中。前端通过动态的add &lt;script&gt;标签的方式获取在静态文件中定义的变量取值。数据分四次获取，每个文件50条，滚动分页的方式加载数据，每次加载10条实现思路将异步和同步数据的处理逻辑分开写。可能遇到的滚动时获取异步数据时可能取不到，需要添加一个flag标志，当数据获取以后再去做数据渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 动态加载scriptfunction loadScript(url,callback) &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.async = 'async'; script.src = url; document.body.appendChild(script); script.onload = function()&#123; callback(); &#125;&#125;// 分情况加载数据function getNews(news_page_num, page_num, isGetScript) &#123; newsLoading = false; var newsData = []; if (isGetScript) &#123; loadScript('https://devtest.yjbtest.com/gjzqwxtest3g/information/data/newsData'+news_page_num+'.json', function() &#123; newsLoading = true; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; renderNews(newsData.slice(0,10)); &#125;); &#125; else &#123; newsLoading = true; var data = []; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; switch (page_num%5) &#123; case 2: data = newsData.slice(10,20); break; case 3: data = newsData.slice(20,30); break; case 4: data = newsData.slice(30,40); break; case 0: data = newsData.slice(40,50); break; &#125; renderNews(data); &#125;&#125; 无限滚动 监听window的scroll事件，在页面的底部放一个loading的div，当滚动事件触发的时候判断loading div据顶部高度是否小于当前文档的高度，如果小于那么loading div就已经展示在页面中了，那么去进行数据获取防止数据请求过于频繁添加了一个定时器在页面数据加载完成的时候移除滚动事件 123456789101112131415161718192021222324252627282930313233window.addEventListener('scroll', scrollLoad, false);function scrollLoad() &#123; if (scrollTimer) &#123; setTimeout(scrollTimer); &#125; scrollTimer = setTimeout(function()&#123; var loadingDom = document.querySelector('.scroll-stance-element'); var loadingDomTop = loadingDom.getBoundingClientRect().top; var windowHeight = window.innerHeight; if (loadingDomTop &amp;&amp; loadingDomTop &lt; windowHeight) &#123; if ($('.new-con-tpl .block').length &lt; 200) &#123; if (!newsLoading) &#123; return; &#125; if (pageNum%5 == 0) &#123; newsPageNum++; &#125; pageNum++; if (pageNum%5 == 1) &#123; getNews(newsPageNum, pageNum, true); &#125; else &#123; getNews(newsPageNum, pageNum); &#125; &#125; else &#123; $('.scroll-stance-element').addClass('hidden'); $('.new-nomore').removeClass('hidden'); window.removeEventListener('scroll', scrollLoad, false); &#125; &#125; &#125;, 100);&#125; 根据屏幕宽度对字符串动态进行截取 截取字符串计算文档的宽度获取当前的字号计算当前可以容纳的字数 进入其他项目咨询页面配置页面路由 由于需要跳转至另一个framework7项目中，因此配置了相关的进入页面的路由 1234567// 获取url里的信息function getQueryValue(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null)return unescape(r[2]); return null;&#125; jsonp和直接引入静态js文件(理解jsonp)本次中由于只有静态文件，本次以引入文件的方式，在文件加载完成的时候获取约定的变量的方式获取和引入本地文件一样的道理比较通俗易懂的方式理解jsonp: http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 其它文档加载的两个函数DOMContentLoaded， load 在chrome network面板中可以很清新的看到DOMContentLoaded页面基本结构加载完成后显示完成时间。和jquery中的$(function(){})一致当初始HTML文档已完全加载和解析时，将触发DOMContentLoaded事件，而无需等待样式表，图像和子框架完成加载。——MDNhttps://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded 1234567document.addEventListener("DOMContentLoaded", function() &#123; // ...代码...&#125;, false);// DOMContentLoaded$(document).ready(function() &#123; // ...代码...&#125;); load页面完全加载显示完成时间 当一个资源及其依赖资源已完成加载时，将触发load事件。 ——MDN 123456window.addEventListener("load", function() &#123; // ...代码...&#125;, false);$(document).load(function() &#123; // ...代码...&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型，原型链笔记]]></title>
    <url>%2F2017%2F06%2F30%2F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解原型，原型链需要了解 原型对象 构造函数 实例三者之间的关系 原型 每个对象(Person)都会有一个原型对象，对象的实例(p1)包含一个隐式的指针指向原型对象 p1.propo === Person.prototype 原型链 如图所示 存在一个对象Student，想拥有Person的一些属性和方法，那么Student.proportype = new Person();那么new Student（）的实例就会存在Student 存在一个隐士指针指向Student的原型对象，而Student的原型指向了person的原型，由于所有自定义对象都是从Object对象继承来的，那么person的原型有指向了Object的原型 总结（摘自红宝书，第6章） 1 原型链之间为引用关系，因此对象实例共享所有的属性和方法，在原型链中的引用类型，因此不适宜单独使用，解决这个问题是利用构造函数，在子类构造函数的内部调用超类的构造函数(Person.call(this, name,,))，这样可以做到每个实例都具有自己的属性，同时还能保证只是用构造函数模式来定义类型。 2 对象可以在编码执行过程中创建和增强，因此具有动态性而非严格定义的实体。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function f() &#123;&#125;; f.prototype = o; return new f();&#125;function inher(sub,sup)&#123; var prototype = object(sup.prototype); // 创建对象 prototype.constructor = sub; // 增强对象 sub.prototype = prototype; // 指定对象&#125;function sup(name) &#123; this.name = name; this.color = ['blue','red']&#125;sup.prototype.sayName = function() &#123; console.log(this.name)&#125;function sub(name,age) &#123; sup.call(this, name); this.age = age;&#125; inher(sub,sup);sub.prototype.sayAge = function() &#123; console.log(this.age);&#125;var s1 = new sub() 其它一个不错的在线编辑绘制图片工具：processon在问答网站回答问题可以促使去各处查资料，优化表达，学习更全面的知识]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现列表标题标题头第一列最后一列固定]]></title>
    <url>%2F2017%2F05%2F24%2F%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E6%A0%87%E9%A2%98%E6%A0%87%E9%A2%98%E5%A4%B4%E7%AC%AC%E4%B8%80%E5%88%97%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%97%E5%9B%BA%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[实现列表标题标题头第一列最后一列固定 实现思路：创建三个div，布局为左中右，其中每个div中设置为上下结构（上为列表的表头，下为数据部分）左右：{overflow：hide, 宽度：固定值， 高度：根绝文档设置高度}中间：{overflow：auto, 宽度：文档宽度-左右宽度， 高度：根绝文档设置高度}js代码处理：上下滚动，左右的div scrollTop和当前滚动的divscrollTop, 左右滚动同理 代码：html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script type="text/template7" id="container-fluid-tpl"&gt; &lt;div class="left_div"&gt; &lt;div class="left_div1"&gt; &lt;table class="left_table1"&gt; &lt;tr&gt; &lt;th&gt;基金名称&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="left_div2"&gt; &lt;table class="left_table2"&gt; &#123;&#123;#each dataLeft&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="name &#123;&#123;font&#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class="code"&gt;&#123;&#123;code&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div"&gt; &lt;div class="data_div1"&gt; &lt;div class="data_divx"&gt; &lt;table class="data_table1"&gt; &lt;tr&gt; &lt;th&gt;认/申购费率&lt;/th&gt; &lt;th class="active"&gt;日涨幅&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1周&lt;i class="iconfont icon-arrow-down2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近3月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近6月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;今年以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近一年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近三年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;成立以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div2"&gt; &lt;table class="data_table2"&gt; &#123;&#123;#each dataCenter&#125;&#125; &lt;tr&gt; &lt;td&gt; &lt;div class="&#123;&#123;center1.status11&#125;&#125;"&gt;&#123;&#123;center1.center11&#125;&#125;&lt;/div&gt; &lt;div class="&#123;&#123;center1.status12&#125;&#125;"&gt;&#123;&#123;center1.center12&#125;&#125;&lt;/div&gt; &lt;/td&gt; &lt;td class="&#123;&#123;center2.status&#125;&#125;"&gt;&#123;&#123;center2.center2&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center3&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center4&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center5&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center6&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center7&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center8&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center9&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center10&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="right_div"&gt; &lt;div class="right_div1"&gt; &lt;table class="right_table1"&gt; &lt;tr&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="right_div2"&gt; &lt;table class="right_table2"&gt; &#123;&#123;#each dataRight&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="buy-btn"&gt;&#123;&#123;this&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135.container-fluid &#123; table &#123; width: 100%; max-width: 100%; margin-bottom: 20px; &#125; .red &#123; color: #ff0000; &#125; .green &#123; color: #1bc01b; &#125; .gray &#123; color: #a3a3a3; &#125; .tlt&#123; color: #a3a3a3; text-decoration: line-through; &#125;&#125;.left_table1 th, .data_table1 th, .right_table1 th &#123; font-size: 13px; font-weight: 500; color: #686868; text-align: center; background: #F0F1F3; padding: 7px 0;&#125;.left_table2 th, .data_table2 td, .right_table2 th &#123; word-break: break-all; font-size: 15px; font-weight: 500; text-align: center; background: #fff; border-bottom: 1px solid #efeff4; height: 90px; .fs15 &#123; font-size: 15px; &#125; .fs13 &#123; font-size: 13px; &#125; &#125;.left_div&#123; width:120px; float: left; .left_div1&#123; width: 100%; &#125; .left_div2&#123; margin-top:-20px; width: 100%; overflow: hidden; &#125; .left_table1 th &#123; text-align: left; padding-left: 16px; &#125; .left_table2 th &#123; text-align: left; padding-left: 16px; .name &#123; color: #424647; &#125; .code &#123; font-size: 13px; color: #888; &#125; &#125;&#125;.right_div&#123; width:80px; float: left; .right_div1&#123; width: 100%; &#125; .right_div2&#123; margin-top:-20px; width: 100%; // height: 72vh; overflow: hidden; &#125; .right_table2 .buy-btn&#123; font-size: 14px; color: #fff; background: #e15b54; display: inline-block; width: 60px; height: 24px; line-height: 24px; border-radius: 2px; &#125;&#125;.data_div&#123; float: left; .data_div1&#123; width: 100%; overflow: auto; &#125; .data_divx&#123; width: 900px; &#125; .data_div2&#123; margin-top:-20px; width:100%; // height:72vh; overflow: auto; -webkit-overflow-scrolling: auto; // -webkit-overflow-scrolling: touch; &#125; .data_table1&#123; width: 880px; .iconfont &#123; font-size: 12px; &#125; th.active&#123; color: #e15b54; &#125; &#125; .data_table2&#123; /**width和max-width一起写，手机浏览器打开也能固定长度**/ width: 880px; max-width: 880px; white-space:nowrap; &#125; .data_table1 th&#123; width:10%; &#125; .data_table2 td&#123; width:10%; &#125;&#125; js1234567891011121314151617181920212223242526function createTab(selector, data) &#123; var template = $$('#container-fluid-tpl').html(); var complieTemplate = Template7.compile(template); var renderTemplate = complieTemplate(data); $$(selector+' .container-fluid').html(renderTemplate); var right_div2 = document.querySelector(selector+' .data_div2'); var data_div1 = document.querySelector(selector+' .data_div1'); right_div2.onscroll = function()&#123; var right_div2_top = this.scrollTop; var right_div2_left = this.scrollLeft; document.querySelector(selector+' .left_div2').scrollTop = right_div2_top; document.querySelector(selector+' .right_div2').scrollTop = right_div2_top; document.querySelector(selector+' .data_div1').scrollLeft = right_div2_left; &#125; data_div1.onscroll = function()&#123; var data_div1_left = this.scrollLeft; document.querySelector(selector+' .data_div2').scrollLeft = data_div1_left; &#125; //设置右边div宽度 var tabHeight = $$('body').height()-$$('.navbar').height()-$$('.tab-nav').height()-$$(selector+' .data_divx').height() document.querySelector(selector+' .data_div').style.width=""+$$('body').width()-200+"px"; document.querySelector(selector+' .left_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .data_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .right_div2').style.height=tabHeight+"px"; &#125; 问题&amp;总结1 苹果手机出现滚动条时会有橡皮条效果通过-webkit-overflow-scrolling设置 -webkit-overflow-scrolling: auto; // 橡皮条效果，滚动速度较慢 -webkit-overflow-scrolling: touch; // 默认效果 2 横向滚动条scroll事件频繁触发，（网页中）页面显示会有些错位。（待优化）。3 元素距离参考图片 offset- offsetWidth(包含padding、border、不包含margin) offsetHeight(同上) offsetLeft(返回元素的x坐标，相对于offsetParent；如果offsetParent为null,则返回对应的文档坐标) offsetTop(同上,返回元素的y坐标) offsetParent(返回最近的包含该元素的定位元素) client- clientWidth(不包含border、margin、滚动条) clientHeight(同上) clientLeft(相当于border-left-width,属性设置元素的左边框的宽度。) clientTop(相当于border-top-width) scroll- scrollWidth(不包含border、margin，返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）, scrollWidth的值要大于clientWidth。) scroHeight(同上) scrollLeft(可读写，获取或设置元素滚动条的位置) scrollTop(同上)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ学习1]]></title>
    <url>%2F2017%2F05%2F15%2FJQ%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[jq结构1234567(function( window, undefined ) &#123; // If there is a window object, that at least has a document property, // define jQuery and $ identifiers if ( typeof window === "object" &amp;&amp; typeof window.document === "object" ) &#123; window.jQuery = window.$ = jQuery; &#125;&#125;)( window ); 传入window对象时防止压缩时window被处理为普通变量undefined在一些浏览器中可以对undefined进行修改 JQ对象上的属性和方法1234567891011121314jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context, rootjQuery );&#125;jquery.fn = jquery.prototype = &#123; jquery: 版本, constructor: 修正指针指向问题, init: 初始化和参数管理, selector: 存储选择字符串, length: this对象的长度, toArray: 传数组, ...&#125;jQuery.fn.init.prototype = jQuery.fn; 参考文章 init方法123456789101112131415jQuery.fn = jQuery.prototype = &#123; init: function() &#123; $(""), $(null), $(undefined), $(false) $('#div1') $('.box') $('div') $('#div1 div.box') $('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $(this) $(document) $(function()&#123;&#125;) $([]) $(&#123;&#125;) return jQuery.makeArray( selector, this ); &#125;&#125; 备注：1 constructor以字面量的方式定义对象，需要指定当前的constructor2 prototype, constructor, 面向对象概念理解]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习笔记]]></title>
    <url>%2F2017%2F05%2F03%2Fcanvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简单例子123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="application/javascript"&gt; function draw() &#123; var canvas = document.getElementById("canvas"); if (canvas.getContext) &#123; var ctx = canvas.getContext("2d"); ctx.fillStyle = "rgb(200,0,0)"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = "rgba(0, 0, 200, 0.5)"; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="draw();"&gt; &lt;canvas id="canvas" width="150" height="150"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 直接可以绘制图形的方法fillRect(x, y, width, height)绘制一个填充的矩形strokeRect(x, y, width, height)绘制一个矩形的边框clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。 绘制基本图形，文本，图片，变换translate(x, y)translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。fillStyle = color设置图形的填充颜色。strokeStyle = color设置图形轮廓的颜色。globalAlpha = transparencyValue这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。lineWidth = value设置线条宽度。lineCap = type设置线条末端样式。shadowOffsetX = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowOffsetY = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowBlur = float shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。shadowColor = color shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。 绘制路径beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。closePath()闭合路径之后图形绘制命令又重新指向到上下文中。当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。stroke()通过线条来绘制图形轮廓。fill()通过填充路径的内容区域生成实心的图形moveTo(x, y)将笔触移动到指定的坐标x以及y上。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。lineTo(x, y)绘制一条从当前位置到指定x以及y位置的直线。arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。quadraticCurveTo(cp1x, cp1y, x, y)绘制贝塞尔曲线，cp1x,cp1y为控制点，x,y为结束点。rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。save()restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 推荐基于canvas小游戏 基于canvas的小游戏 详细canvas APIMDNcanvas API]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build-blog]]></title>
    <url>%2F2017%2F05%2F03%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start导入hexo1$ npm install -g hexo-cli --registry=https://registry.npm.taobao.org 初始化项目1$ hexo init Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites123456789$ hexo deploy// 报错:ERROR Deployer not found: githubnpm install hexo-deployer-git --savedeploy: type: git // 或者github repository: git@github.com:lvSally/lvSally.github.io.git branch: master 其它1 使用hexo new page tags/categories 创建分类或标签2 在themes _config.yml 控制主体显示3 themes -&gt; _config.yml -&gt; baidu_analytics 添加百度统计id可添加百度统计功能4 themes -&gt; _config.yml -&gt; avatar 设置头像5 next第三方服务集成6 网易云跟帖 悲剧的是类似github.io的子域名基本信息填写不能通过7 Disqus,最终选择了Disqus，缺点是需要翻墙，使用Disqus比较简单，注册一个账号，在主题的设置文件中添加以下shortname即可。More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>