<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue源码阅读1]]></title>
    <url>%2F2018%2F11%2F15%2Fvue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1%2F</url>
    <content type="text"><![CDATA[3-4月前，在丁香园面试那个架构师就问为什么要阅读源码，我们需要阅读源码吗，当时他给我的结论是是不需要阅读源码，在没有目标时无需跟风去阅读源码，那个时候的收获可能也不会多。这些时间断断续续开始了vue的源码阅读之路，觉得阅读源码还是蛮重要的，感觉分为几个维度：1 从init开始阅读了解大型成熟框架的结构，对框架有个整体认识2 一行行阅读源码的时候好像在玩游戏，主线是必须走的，有些分支感兴趣想去玩一下可以去看一下，说不定会有意外收获3 主要查看部分： 响应式，数据驱动… 这个阶段大多数是在巩固之前的基础知识 constructorFn 将方法按照功能分类放在不同的函数中，执行函数绑定方法，使结构更加清晰 123456789101112131415161718192021222324252627282930313233343536373839// 构造函数function Vue() &#123; if (!this instanceof Vue) &#123; console.log(&apos;必须使用关键字&apos;) &#125; this.name = &apos;__vue&apos; this._init()&#125;// 给构造函数增加属性或方法// 直接添加Vue.prototype.testFn = () =&gt; &#123;&#125;// 调用函数添加initFn(Vue)otherFn(Vue)function initFn(vue) &#123; vue.prototype._init = function() &#123; console.log(&apos;init&apos;); &#125;&#125;function otherFn(vue) &#123; vue.prototype._other = function() &#123; console.log(&apos;ohter&apos;) &#125;&#125;// 实例化构造函数var vue = new Vue()Vue.prototype.testFn2 = () =&gt; &#123; console.log(&apos;testFn2&apos;)&#125;vue._other()vue.testFn2()console.log(vue.hasOwnProperty(&apos;name&apos;)) // trueconsole.log(vue.hasOwnProperty(&apos;testFn&apos;)) // falseconsole.log(vue.hasOwnProperty(&apos;otherFn&apos;)) // falseconsole.log(vue.hasOwnProperty(&apos;testFn2&apos;)) // false defineProperty 阅读js对象是，红宝书用了很多页在描述这个属性，然而自己用不到.. 123456789101112131415161718192021222324function Vue() &#123;&#125;// 给构造函数添加属性(添加静态方法)Vue.options = Object.create(null) // 没有继承的属性Vue.options._base = &apos;_base&apos;// configconst config = &#123; opt1: &quot;opt1&quot;, opt2: &quot;opt2&quot;&#125;const configDef = &#123;&#125;configDef.get = () =&gt; configObject.defineProperty(Vue, &apos;config&apos;, configDef) // 通过defineProperty细化的定义属性，给构造原函数定义属性// Object.defineProperty(Vue, &apos;config&apos;, &#123; get: () =&gt; config &#125;) // 同上console.log(Vue.options)console.log(Vue.config) // 可以访问只读属性configconsole.log(Vue) // 变了Vue的属性中不会遍历config// 通过defineProperty给实例定义属性let vue = new Vue()Object.defineProperty(vue, &apos;config&apos;, &#123; get: () =&gt; &apos;实例&apos; &#125;)console.log(vue.config) cached 这个方法目前还不清楚用来做什么..,使用了闭包将数据保存在内存中,内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments之外） 12345678910111213141516171819function cached (fn) &#123; const cache = Object.create(null) return (function cachedFn (str) &#123; console.log(cache) const hit = cache[str] return hit || (cache[str] = fn(str)) &#125;)&#125;const idToTemplate = cached(id =&gt; &#123; debugger return id&#125;)console.log(idToTemplate(1))console.log(idToTemplate(12))console.log(idToTemplate(123))// 内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments之外）// 如果需要访问对象的name属性的话，就需要显示的定义一个变量that来引用this，而这个变量此时就指向object对象了。 mount mount没有关注有什么功劳，但是写法很好玩，先是将原始的prototype.$mount赋值给一个变量，然后重新定义改属性并通过call应用之前的功能实现拓展。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Vue() &#123; this.name = &apos;name&apos;&#125;// 定义静态属性，通过Vue.static_pro访问Vue.static_pro = &apos;static_pro&apos;Vue.prototype.$mount = function() &#123; console.log(&apos;old&apos;)&#125;const mount = Vue.prototype.$mountVue.prototype.$mount = function () &#123; console.log(this.name) // 通this访问当前对象的上的属性 console.log(&apos;new&apos;) return mount.call(this)&#125;const vue = new Vue();console.log(vue.$mount())// call使用function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = &apos;food&apos;;&#125;console.log(new Food(&apos;cheese&apos;, 5).name);// --------------插曲---------------// 重新赋值let test = &#123; a: 1, b: 2&#125;let test1 = testtest1 = &#123; c: 3&#125;console.log(test, test1)// 修改引用let test = &#123; a: 1, b: 2&#125;let test1 = testtest1.c = 3console.log(test, test1) performance 好玩的属性出体验–window.performance,之前竟然不知道有这么个检测性能的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ------------mark,measure定义--------------export let markexport let measureif (process.env.NODE_ENV !== &apos;production&apos;) &#123; const perf = inBrowser &amp;&amp; window.performance /* istanbul ignore if */ if ( perf &amp;&amp; perf.mark &amp;&amp; perf.measure &amp;&amp; perf.clearMarks &amp;&amp; perf.clearMeasures ) &#123; mark = tag =&gt; perf.mark(tag) measure = (name, startTag, endTag) =&gt; &#123; perf.measure(name, startTag, endTag) perf.clearMarks(startTag) perf.clearMarks(endTag) perf.clearMeasures(name) &#125; &#125;&#125;// ------------mark,measure使用--------------if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile&apos;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile end&apos;) measure(`vue $&#123;this._name&#125; compile`, &apos;compile&apos;, &apos;compile end&apos;) &#125;&#125; _data同名属性访问器 众多技巧只有，通过this可以方便的访问到data中的属性 vue实例之所以能访问_data中的同名属性，是因为在对象上添加了同名属性, 添加技巧，通过Object.defineProperty(obj, key, config)重写get和set方法实现 123456789101112131415const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: () =&gt; &#123;&#125;, set: () =&gt; &#123;&#125;&#125;export function proxy (target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画基础]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[图片地址 学习动画模块我企图分为两部分，1动画基础；2查看大型框架对动画应用。很显然第二部分力不存心，这是一份拖了很久的动画总结隐式过渡: 通常我们修改元素样式反生改变我们称为隐式过渡，因为转变的完成由浏览器决定。css transition: 现在我们加入动画，那么可以决定哪些属性发生动画效果 (property)，何时开始 (delay），持续多久 (duration) 以及如何动画 (定义timing funtion)。 动画的基本使用transition 12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;box&quot; click=&quot;&quot;&gt; 盒子 &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box &#123; border: 1px solid; width: 100px; height: 100px; transition: 1s; &#125; .box.move &#123; transform: translate(200px, 200px); &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;const box = document.querySelector(&apos;.box&apos;)box.addEventListener(&apos;click&apos;, function() &#123; box.classList.toggle(&apos;move&apos;)&#125;)&lt;/script&gt; animation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;body&gt; &lt;div class=&quot;box&quot;&gt; 盒子 &lt;/div&gt; &lt;p&gt;Move your mouse over the grey box&lt;/p&gt; &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;grows&quot;&gt;This just grows&lt;/div&gt; &lt;div class=&quot;growsandstays&quot;&gt;This grows and stays big&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box &#123; border: 1px solid; width: 100px; height: 100px; animation-name: moveBox; animation-duration: 1300ms; animation-iteration-count: infinite; animation-direction: alternate; &#125; @keyframes moveBox &#123; 0% &#123; transform: translate(0, 0); opacity: 0.1; &#125; 25% &#123; opacity: 0.3 transform: translate(100px, 100px); &#125; 50% &#123; opacity: 0.6 transform: translate(200px, 200px); &#125; 100% &#123; opacity: 0.9; transform: translate(300px, 300px); &#125; &#125; .demo &#123; border-top: 100px solid #ccc; height: 300px; font-family: sans-serif; font-size: 14px; &#125; /* @keyframes grow &#123; 0% &#123; font-size: 0 &#125; 100% &#123; font-size: 40px &#125; &#125; */ /* .demo:hover .grows &#123; animation-name: grow; animation-duration: 3s; &#125; */ /* .demo:hover .growsandstays &#123; animation-name: grow; animation-duration: 3s; animation-fill-mode: both; &#125; */ @keyframes slidein &#123; from &#123; transform: scaleX(0); &#125; to &#123; transform: scaleX(1); &#125; &#125; .demo:hover .grows &#123; animation: running slidein 3s ease-in 1s infinite reverse both; &#125;&lt;/style&gt; web animation API 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=&quot;box&quot;&gt; 盒子 &lt;/div&gt;&lt;/body&gt;&lt;style&gt; .box &#123; border: 1px solid; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt; const box = document.querySelector(&apos;.box&apos;) let player = box.animate([ &#123; transform: &apos;translate(0)&apos; &#125;, &#123; transform: &apos;translate(200px, 200px)&apos; &#125; ], 500) box.addEventListener(&apos;click&apos;, () =&gt; &#123; player.play() &#125;) player.addEventListener(&apos;finish&apos;, function() &#123; box.style.transform = &apos;translate(100px, 100px)&apos;; console.log(player) &#125;);&lt;/script&gt; 简单的案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;view list&quot;&gt; &lt;span class=&quot;detail-btn&quot;&gt;detail&lt;/span&gt; &lt;span class=&quot;show-modeal&quot;&gt;show-modeal&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;view details&quot;&gt; &lt;span class=&quot;back-btn&quot;&gt;back&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;style&gt;body &#123; margin: 0;&#125;.container &#123; width: 100%; height: 100vh; overflow: hidden; position: relative;&#125;.view &#123; width: 100%; height: 100%; position: absolute; left: 0; top: 0; background: #ccc; transition: transform 0.3s cubic-bezier(0.465, 0.183, 0.153, 0.946); /* [will-change]:(https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change) let the browser know we plan to animate each view in and out */ will-change: transform;&#125;.details &#123; background: green; transform: translateX(100%);&#125;.view-change .list &#123; transform: translateX(-100%);&#125;.view-change .details &#123; transform: translateX(0);&#125;.modal &#123; position: fixed; top: 100px; left: 100px; width: 100px; height: 100px; background: red; z-index: 100; pointer-events: none; opacity: 0; transform: scale(1.15); transition: transform 0.1s cubic-bezier(0.465, 0.183, 0.153, 0.946), opacity 0.1s cubic-bezier(0.465, 0.183, 0.153, 0.946); will-change: transform, opacity;&#125;.modal.visible &#123; pointer-events: auto; transform: scale(1); opacity: 1;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt; const detailBtn = document.querySelector(&apos;.detail-btn&apos;) const backBtn = document.querySelector(&apos;.back-btn&apos;) const container = document.querySelector(&apos;.container&apos;) const showModeal = document.querySelector(&apos;.show-modeal&apos;) const modal = document.querySelector(&apos;.modal&apos;) detailBtn.addEventListener(&apos;click&apos;, () =&gt; &#123; container.classList.toggle(&apos;view-change&apos;) &#125;) backBtn.addEventListener(&apos;click&apos;, () =&gt; &#123; container.classList.toggle(&apos;view-change&apos;) &#125;) showModeal.addEventListener(&apos;click&apos;, () =&gt; &#123; modal.classList.toggle(&apos;visible&apos;) &#125;) modal.addEventListener(&apos;click&apos;, () =&gt; &#123; modal.classList.toggle(&apos;visible&apos;) &#125;)&lt;/script&gt; 其他 动画用法比起其他的样式属性稍稍多了一些，动画在在页面展示中还是比较重要的。比如当一个alert弹窗出现时，迅速弹出让用户感觉比较快的响应，稍稍慢一些关闭给人一种缓和的感觉，这样播放动画会给人一种比较友好的感觉。现在的开发中多数被封装在了框架中，我们可以轻松的实现动画。 贝塞尔曲线介绍transitionanimation动画详解动画性能缓动函数]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化总结]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是一篇文字搬运，弥补不太好的记忆,期待哪天写一份有灵魂的总结。。 资源合并与压缩图片相关优化 jpeg: 有损压缩，对应图片质量要求不高的情况可以使用png8: 支持透明png24: 不支持透明png32: 支持透明svg,iconfont， img inline css、js的加载和执行 当我们在浏览器中输入一个地址。浏览器会搜索有没有配置相应的DNS,如果配置走host中配置的地址，经过（主干网-》交换机-》路由器-》主干网）网络走到服务端，在服务的control -》 model -》 db 层进行逻辑处理，返回至前端。前端首先拿到一个html字符串，浏览器解析器将其从上之下按顺序加载。遇到css和js,以及HTML会被转化成 dom cssom最终合成渲染树-》layout(combine layout) -&gt; paint在这个过程中通过使用cdn请求，了解js, css阻塞情况合理使用defer，asynchtml渲染特点：顺序执行，并发加载（由于浏览器是有并发度的，同时请求同一个地址达到并发度会等到资源加载完成以后再次加载）引入方式css阻塞: 1 css head中阻塞页面渲染 2 css阻塞js的执行 3 css不阻塞外部资源加载js阻塞： 1 直接引入的js阻塞页面的渲染 2 js不阻塞资源的加载 3 js顺序执行，阻塞后续js执行逻辑依赖关系页面渲染依赖css的加载js执行顺序的依赖关系js逻辑对应dom节点的依赖关系 重绘与回流 当页面的结构发生改变，通常一些几何属性发生改变时会出发重绘, 只是展示外观的属性发生改变时会出发重绘，出发回流时必将出发重绘触发重布局的属性： 盒模型属性，定位属性，文字结构属性触发重绘的属性：一些颜色属性 dom创建过程1 获取dom后分割成多个图层2 对每个图层节点计算样式结果（样式重计算）3 为每个节点生成图层和位置(回流和重布局)4 将每个节点绘制天成到图层位图中（重绘）5 图层作为文理上传至GPU6 合并图层最终生成屏幕图像（合并图层） 创建图层条件(图层合并是一个比较耗时的操作，关注图层产生的条件是必要的)3D或透视变换(perspective transform)CSS属性使用加速视频解码的节点拥有3D(WebGL)上下文或加速的2D上下文的节点混合插件(如Flash)对自己的opacity做CSS动画或使用一个动画webkit变换的元素拥有加速CSS过滤器的元素元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） 优化点对应动画新建一个图层避免一条条的修改节点样式，最好写在一个class里面使用opacity代替visibility使用tansform替代top..避免使用table布局，因为对table进行修改时可能导致整个页面重绘dom离线修改，先将dom节点设置为display: none,修改完成再显示使用requestanimationFrame代替定时器window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。requestAnimationFrame chrome 上可以看到dom在构建期间各个阶段所消耗的时间以及更详细的解决方案。开发者工具性能优化 懒加载和预加载 懒加载懒加载： 通常被应用于图片加载。很多电商网站中会加载很多图片，当图片请求较多时，导致页面加载较慢，甚至会影响一些js或者css的下载，这种情况就会使用到懒加载。懒加载和滚动加载实现原理是类似的，利用滚动事件，当我们定义的某个元素出现在我们规定的位置时触发一些函数。预加载： 在一些场景下比如动画播放，要保证动画的连贯性，就需要时一些资源提前加载，或者是在资源空置时。这个时候就需要预加载，预加载通常的手段有使用img标签，使用image对象，使用xhr,缺点是不支持跨域。也有相应的库封装了preload。12345678910111213141516171819202122232425262728// 懒加载var viewHeight = document.documentElement.clientHeight // 可视区域的高度function lazyload () &#123; var eles = document.querySelectorAll(&apos;img[data-original][lazyload]&apos;) Array.prototype.forEach.call(eles, function (item, index) &#123; var rect if (item.dataset.original === &apos;&apos;) return rect = item.getBoundingClientRect() if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123; !function () &#123; var img = new Image() img.src = item.dataset.original img.onload = function () &#123; item.src = img.src &#125; item.removeAttribute(&apos;data-original&apos;) item.removeAttribute(&apos;lazyload&apos;) &#125;() &#125; &#125;)&#125;lazyload()document.addEventListener(&apos;scroll&apos;, lazyload) 浏览器存储cookie， localStorage， sessionStorage， indexDB 缓存 分级缓存（优先级从上到下）1 浏览器缓存 根据cache control、expires来判断是否在浏览器过期，没有过期在Chrome中可以看到from memory catch 中获取。如何配置了no-cache会每次向服务器请求资源， 配置no-store 将不会读取服务端缓存，直接请求最新内容2 服务端缓存 如果配置了 etag/last-modified, 请求时携带if-none-match/if-modify-since来判断是否一致，如果一致返回3043 没有缓存返回200 服务端性能优化]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识MongoDB]]></title>
    <url>%2F2018%2F03%2F23%2F%E5%88%9D%E8%AF%86MongoDB%2F</url>
    <content type="text"><![CDATA[初识mongo 认识 1 非关系型数据库，缺点是当两张表需要建立连接的时候处理起来比较麻烦 2 以集合的方式操作和保存数据 3 非常轻量，和node搭配实现了前端可以方便对数据进行存取，让前端找到了存在感.. 安装和使用 1 下载 2 在mac中直接解压，进入二进制文件夹bin目录 3 启动数据库，并制定数据存放位置 12cd Applications/mongodb/bin./mongod --dbpath /Users/lvjingjing/mongo-data 4 在可视化工具(robo 3T)中查看数据. 下载 基本使用 方法封装 通过下面的封装方法记录mongo基本的增删改查,以及node中如何引入mongodb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * Created by Danny on 2015/9/25 9:31. *///这个模块里面封装了所有对数据库的常用操作var MongoClient = require(&apos;mongodb&apos;).MongoClient;var settings = require(&quot;../settings.js&quot;);//不管数据库什么操作，都是先连接数据库，所以我们可以把连接数据库//封装成为内部函数function _connectDB(callback) &#123; // &quot;dburl&quot; : &quot;mongodb://localhost:27017/test&quot;, test对应的数据库 var url = settings.dburl; //从settings文件中，都数据库地址 //连接数据库 MongoClient.connect(url, function (err, db) &#123; if (err) &#123; callback(err, null); return; &#125; callback(err, db); &#125;);&#125;init();function init()&#123; //对数据库进行一个初始化 _connectDB(function(err, db)&#123; if (err) &#123; console.log(err); return; &#125; db.collection(&apos;users&apos;).createIndex( &#123; &quot;username&quot;: 1&#125;, null, function(err, results) &#123; if (err) &#123; console.log(err); return; &#125; console.log(&quot;索引建立成功&quot;); &#125; ); &#125;);&#125;//插入数据exports.insertOne = function (collectionName, json, callback) &#123; _connectDB(function (err, db) &#123; db.collection(collectionName).insertOne(json, function (err, result) &#123; callback(err, result); db.close(); //关闭数据库 &#125;) &#125;)&#125;;//查找数据，找到所有数据。args是个对象&#123;&quot;pageamount&quot;:10,&quot;page&quot;:10&#125;exports.find = function (collectionName, json, C, D) &#123; var result = []; //结果数组 if (arguments.length == 3) &#123; //那么参数C就是callback，参数D没有传。 var callback = C; var skipnumber = 0; //数目限制 var limit = 0; &#125; else if (arguments.length == 4) &#123; var callback = D; var args = C; //应该省略的条数 var skipnumber = args.pageamount * args.page || 0; //数目限制 var limit = args.pageamount || 0; //排序方式 var sort = args.sort || &#123;&#125;; &#125; else &#123; throw new Error(&quot;find函数的参数个数，必须是3个，或者4个。&quot;); return; &#125; //连接数据库，连接之后查找所有 _connectDB(function (err, db) &#123; var cursor = db.collection(collectionName).find(json).skip(skipnumber).limit(limit).sort(sort); cursor.each(function (err, doc) &#123; if (err) &#123; callback(err, null); db.close(); //关闭数据库 return; &#125; if (doc != null) &#123; result.push(doc); //放入结果数组 &#125; else &#123; //遍历结束，没有更多的文档了 callback(null, result); db.close(); //关闭数据库 &#125; &#125;); &#125;);&#125;//删除exports.deleteMany = function (collectionName, json, callback) &#123; _connectDB(function (err, db) &#123; //删除 db.collection(collectionName).deleteMany( json, function (err, results) &#123; callback(err, results); db.close(); //关闭数据库 &#125; ); &#125;);&#125;//修改exports.updateMany = function (collectionName, json1, json2, callback) &#123; _connectDB(function (err, db) &#123; db.collection(collectionName).updateMany( json1, json2, function (err, results) &#123; callback(err, results); db.close(); &#125;); &#125;)&#125;//得到总数量exports.getAllCount = function (collectionName,callback) &#123; _connectDB(function (err, db) &#123; db.collection(collectionName).count(&#123;&#125;).then(function(count) &#123; callback(count); db.close(); &#125;); &#125;)&#125;]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax请求从前端至后端]]></title>
    <url>%2F2018%2F03%2F22%2Fajax%E8%AF%B7%E6%B1%82%E4%BB%8E%E5%89%8D%E7%AB%AF%E8%87%B3%E5%90%8E%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[图片地址 由express中的request引发的血案 像论坛上说的一样，express框架几乎不用怎么阅读文档就可以搞起了。最最常见的就是处理get和post请求了，处理过程中获取get和post数据相差很大，处理post请求还需要额外引入一些包。前端的ajax请求jQ已经帮我们封装好了，所以感知不到get和post的传值的不同。 出于想搞明白这些问题做了一些实验 1 express如何处理get、post 2 Content-Type是个什么东西，对后端处理数据有什么影响 3 原生xhr都做了什么 前端对于post和get的不同处理理解总结 get 追加在URL后通过序列化的字符串提交 post 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 主要有四种POST数据提交方式，前两种格式比较常用 1 application/x-www-form-urlencoded（jq，默认的表单提交格式） 通常写法: param1=111&amp;param2=222 在XMLHttpRequest2中创建了FormData格式，方便数据表现形式为 1234var form = new FormData();form.append(&apos;param1&apos;, &apos;111&apos;);form.append(&apos;param2&apos;, &apos;222&apos;);xhr.send(form); 2 application/json（由于json格式的流行，这种格式被广泛接受） 3 text/xml 4 multipart/form-data 参考 四种常见的 POST 提交数据方式 post请求，xhr.send(data)函数的data参数类型有哪些？ 使用原生ajax写法 简易版get: 123456var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;http://localhost:3000/api/run/getMarks?param=999&amp;param2=%E6%88%91%E4%BB%AC%E4%BD%A0%E4%BB%AC999&apos;);xhr.send();xhr.onload = function () &#123; console.log(xhr.response);&#125; 简易版post1(application/x-www-form-urlencoded;charset=UTF-8): 12345678var xhr = new XMLHttpRequest();xhr.open(&apos;POST&apos;, &apos;http://localhost:3000/api/run/setMarks&apos;);// 使用application/x-www-form-urlencodedxhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;);xhr.send(&apos;param=999&amp;param2=%E6%88%91%E4%BB%AC%E4%BD%A0%E4%BB%AC999&apos;);xhr.onload = function () &#123; console.log(xhr.response);&#125; 简易版post2(application/json): 123456789101112var xhr = new XMLHttpRequest();xhr.open(&apos;POST&apos;, &apos;http://localhost:3000/api/run/setMarks&apos;);// 使用application/jsonxhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);var json = &#123; param: &apos;9999&apos;, param2: &apos;我们&apos;&#125;;xhr.send(JSON.stringify(json));xhr.onload = function () &#123; console.log(xhr.response);&#125; Jq版post1: 123456789101112var json = &#123; param: &apos;999&apos;, param2: &apos;我们你们999&apos;&#125;;$.ajax(&#123; url:&quot;http://localhost:3000/api/run/setMarks&quot;, type: &apos;POST&apos;, data: json, success: function(res) &#123; console.log(res); &#125;&#125;); Jq版post2: 1234567891011121314var json1 = &#123; param: &apos;888&apos;, param2: &apos;我们你们&apos;&#125;;$.ajax(&#123; url:&quot;http://localhost:3000/api/run/setMarks&quot;, type: &apos;POST&apos;, contentType: &apos;application/json&apos;, dataType: &apos;json&apos;, data: JSON.stringify(json1), success: function(res) &#123; console.log(res); &#125;&#125;); 完整版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798define([&apos;utils&apos;], function (Utils) &#123; /* global args */ var xhrTimeout; var timeout = 15000; var TIMEOUT_MSG = &apos;连接超时，请稍后重试&apos;; // 维护页面跳转情况 1 服务器返回小于100，大于300的状态， 2 error var core = &#123; // Method that performs the ajax request ajax: function (method, url, args, loading) &#123; // Creating a promise var promise = new Promise(function (resolve, reject) &#123; // Instantiates the XMLHttpRequest var xhr = new XMLHttpRequest(); var uri = url; if (loading &amp;&amp; loading === &apos;nojuhua&apos;) &#123; f7.hideIndicator(); &#125; else &#123; f7.showIndicator(); &#125; xhr.open(method, uri); if (args &amp;&amp; (method === &apos;POST&apos; || method === &apos;PUT&apos;)) &#123; xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;); xhr.send(Utils.serialize(args)); &#125; else &#123; xhr.send(); &#125; xhr.onabort = function () &#123; if (xhrTimeout) &#123; clearTimeout(xhrTimeout); &#125; f7.hideIndicator(); reject(TIMEOUT_MSG); &#125;; xhrTimeout = setTimeout(function () &#123; xhr.abort(); &#125;, timeout); xhr.onload = function () &#123; if (xhrTimeout) &#123; clearTimeout(xhrTimeout); &#125; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; var res = JSON.parse(this.response); if (res.error_no.toString() === &apos;0&apos; || !res.error_no) &#123; resolve(res); f7.hideIndicator(); &#125; else &#123; reject(res.error_info); f7.hideIndicator(); &#125; &#125; else &#123; if (this.status === 500 || this.status === 502 || this.status === 503 || this.status === 504) &#123; displayView.loadPage(&apos;pages/acct/notfound.html&apos;); f7.hideIndicator(); &#125; else &#123; f7.hideIndicator(); reject(this.statusText); &#125; &#125; &#125;; xhr.onerror = function () &#123; if (xhrTimeout) &#123; clearTimeout(xhrTimeout); &#125; f7.hideIndicator(); reject(this.statusText); &#125;; &#125;); return promise; &#125; &#125;; // Adapter pattern return &#123; get: function (url, loading) &#123; return core.ajax(&apos;GET&apos;, url, null, loading); &#125;, post: function (url, args) &#123; return core.ajax(&apos;POST&apos;, url, args); &#125;, put: function (url, args) &#123; return core.ajax(&apos;PUT&apos;, url, args); &#125;, delete: function (url) &#123; return core.ajax(&apos;DELETE&apos;, url, args); &#125; &#125;;&#125;); 在http中post和get数组的存放位置 get参数存放在请求行中 post参数存在于请求正文, 通常不会写在url中.. HTTP 协议简介 express对于post和get的不同处理 123456789101112var express = require(&apos;express&apos;);var bodyParser = require(&quot;body-parser&quot;);var app = express();app.use(bodyParser.json()); // application/jsonapp.use(bodyParser.urlencoded(&#123; extended: false &#125;)); // application/x-www-form-urlencoded;charset=UTF-8app.post(&apos;/api/run/setMarks&apos;, function(req, res)&#123; console.log(req.query); // 输出get的参数 console.log(req.body); // 输出post参数 res.json(&#123;test: &apos;test&apos;&#125;);&#125;) 写在最后花了很多时间去验证一些想法花了很多时间，不过很开心，后期有时间还是要系统去看看http相关的知识:-D。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型图]]></title>
    <url>%2F2018%2F03%2F22%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[上图片图片地址]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react项目总结2]]></title>
    <url>%2F2018%2F02%2F02%2Freact%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%932%2F</url>
    <content type="text"><![CDATA[react项目，ios光标问题 重现这个问题：在react官网上下载appdome, 随便添加一个input，在手机app或者Safari上操作，先让input focus，然后点击其他元素（包括按钮之类的元素），光标不会消失 最终知道是react框架的问题，框架中在document上绑定了blur，导致的 解决方案 1&lt;script&gt;document.addEventListener(&apos;touchstart&apos;,function(e)&#123;(document.activeElement &amp;&amp; document.activeElement != e.target) &amp;&amp; document.activeElement.blur();&#125;);&lt;/script&gt; 参考文件 光标问题2 使用absolute代替了fix解决了顶部固定问题，然而h5还是逃不过一些致命的问题，比如一个页面中存在输入框，ios的键盘又占据页面的一些空间，页面就会出现滚动条，而这种控制已经超越了h5，让我不禁想起那些追求完美的企业对于这种表单是不是直接使用原生解决了 写了一个自己的polyfill 1 将相应的polyfill方法放入自执行的方法中（可以来自mdn或者github）(function() {})() 2 在页面刚开始的时候引入 import “polyfill”; 处理class 1 classList，提供了add、remove、toggle以及contains等方法 2 var classVal = document.getElementById(“id”).getAttribute(“class”); //删除的话 classVal = classVal.replace(“someClassName”,””); document.getElementById(“id”).setAttribute(“class”,classVal ); //添加的话 classVal = classVal.concat(“ someClassName”); document.getElementById(“id”).setAttribute(“class”,classVal ); //替换的话 classVal = classVal.replace(“someClassName”,”otherClassName”); 展开运算符和剩余运算符 剩余运算符 剩余运算符要命名个变量名称的，可以用在函数参数，还有 解构赋值上{a,b,…obj}= {a:1,b:2,c:3,d:4} 展开运算符 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 扩展语法允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。 举个栗子 {…this.props}使用了展开运算符，会把this.props中的属性展开。 {}是jsx识别js使用 name={name} phone={tel} image={image} {…this.props}将作为属性传给MyHead 安卓手机一些兼容性问题总结及扩展 1 webview 相当于一个浏览器 2 a 标签 _blank之类的客户端可以定义一些协议去做特殊解析* 3 android4.4部分flex， svg, canvas属性不支持 4 file浏览器支持，但是部分webview包不支持 5 新版本的chrome不支持window.jtoJHandle，需要判断这个属性是否存在 6 安卓机型下，用户设置整个手机字体大小时，我们app内字体大小受影响，导致页面样式错乱。 原因：我们app的字体大小继承到手机设置的字体大小。 解决方案：需找安卓开发，修改安卓客户端，禁止app继承手机所设置的大小。 7 安卓手机的分水岭4.0-4.3， 4.4 APP调试小结 1 很蠢很方便的方法: alert 2 原生打debug包，然后将手机设置为允许调试状态，那么安卓可以通过chrome://inspect/#devices查看手机上的页面 3 ios有mac就比较方便了，可以在Safari上找到相应的手机，然后找到相应的app 4 比较方便的还是使用vConsole 使用: 因入库，实例化对象，那么手机手机上就会出现一个悬浮按钮，点击可看一些日志 项目调试遇到的坑 遇到一些网址打不开，或者一些开发的服务连不上，或者一些配置信息没有读到，可以能是一下原因，哭 1 网址不能访问可能是开了翻墙软件 2 开发的服务ping不到可能是开了防火墙 3 node的配置文件死活读不到，可能是文件读错了，可以通过打印信息看一些日志。 redux学习总结单页面思考模块切换 江海：spa+f7，增加了view的概念，可以方便模块切换时保存模块的状态，拥有自己的路由和页面跳转方法 浙商：spa+react 想保存某些模块的内容可能只能存在缓存中（利用闭包） 手淘分享，模块切换的问题多是放在原生解决 开屏广告实现方案 开屏广告实现方案：由于h5接口获取和展示页面可能会导致页面一段时间内白屏，因此放在原生处理，利用客户端缓存上一次的广告页，那么展示的也是上一次的广告 第三方app解决方案 涉及第三方网站和我们app有交互，放弃使用iframe，使用h5+原生，其中原生通过新打开一个webview展示第三方，其中返回我的的页面的时候考虑两种情况： 1 直接关闭新的webview，那么再次进入第三方页面时的页面状态将不会保存。 2 隐藏新的webview，原生端认为实现起来比较麻烦，不能和其他项目统一处理]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux]]></title>
    <url>%2F2018%2F02%2F01%2Fredux%2F</url>
    <content type="text"><![CDATA[redux一直没有总结,去看中间件的源码看得更是晕乎乎的，下面的总结是站在大牛的肩膀上看到的远方。 Redux redux说白了就是一个保存全局变量的东西。当一个项目需要处理一个比较复杂的数据流的时候，可能就会出现各种状态管理工具，redux就是其中之一。 可以将redux理解为保存一个可供外部读取和修改的私有变量，利用了闭包的特性。在闭包函数中提供了一些方法：获取，修改，订阅更新 React-Redux redux库是独立存在的，在不是react的项目也可以使用，在react使用redux需要引入React-Redux， React-Redux提供了两个重要的功能： , connect() &lt;Provider/&gt;接受一个 store 作为 props，它是整个 Redux 应用的顶层组件 connect() 提供了在整个 React 应用的任意组件中获 取 store 中数据的功能。子组件通过HOC建立与顶层props.store的联系，进而获取数据、修改数据、更新UI。 HOC 需要使用一些高级的功能，函数中会有高阶函数，react中也存在高阶组件。高阶组件的实现方式通常分成下面两种： 属性代理（props proxy）。高阶组件通过被包裹的 React 组件来操作 props。（redux的connect的实现方式） 反向继承（inheritance inversion）。高阶组件继承于被包裹的 React 组件。 Context 哈哈，把Context比作穿越空间的虫洞很有意思。React中的“虫洞” Context就像javascript中的全局变量，只有真正全局的东西才适合放在context中。 比如：当前用户信息、 flux、redux的store 、session级别信息（语言，主题等） redux使用场景 1 不同组件之间期望不用通过组件代码通信 2 复杂数据流存储 3 …(想作为全局数据保存的数据) 消息模块redux的使用 消息模块的使用场景 由于消息是根据socket实时推送，需要对于下面的数据进行修改。 [ {name: ‘’, log: ‘’, readMum: ‘’}, {name: ‘’, log: ‘’, readMum: ‘’}, {name: ‘’, log: ‘’, readMum: ‘’} ] 那么可能用到： 数据的获取，修改，渲染 定义action123456789101112131415161718192021222324252627282930313233343536373839404142// 获取消息菜单let MESSAGES = [];export function getMsgMenu(menuData, type) &#123; if (type === 0) &#123; // 第一次请求接口加载数据 MESSAGES = menuData; &#125; else if (type === 1) &#123; // websocket推送 // 处理数据 const newMsgType = menuData.type; const newMsgTypeUnReadNum = menuData.num; let breakForLoop = false; for (let i = 0; i &lt; MESSAGES.length; i++) &#123; for (let j = 0; j &lt; MESSAGES[i].childList.length; j++) &#123; if (MESSAGES[i].childList[j].type === newMsgType) &#123; MESSAGES[i].childList[j].unReadNum = newMsgTypeUnReadNum; breakForLoop = true; break; &#125; &#125; if (breakForLoop) break; &#125; &#125; else if (type === 2) &#123; // 点击某一类消息时，把未读消息数置 0 // 此时第一个参数为消息类型 let breakForLoop = false; for (let i = 0; i &lt; MESSAGES.length; i++) &#123; for (let j = 0; j &lt; MESSAGES[i].childList.length; j++) &#123; if (MESSAGES[i].childList[j].type === menuData) &#123; MESSAGES[i].childList[j].unReadNum = &apos;0&apos;; breakForLoop = true; break; &#125; &#125; if (breakForLoop) break; &#125; &#125; return &#123; type: MSG_MENU, payload: MESSAGES &#125;;&#125; 定义reducer12345678910const MSG_MENU = &apos;MSG_MENU&apos;;export default function (state = [], action) &#123; switch (action.type) &#123; case MSG_MENU: return action.payload; default: return state; &#125;&#125; combineReducers12345678910import &#123; combineReducers &#125; from &apos;redux&apos;;import appMenuReducer from &apos;./app-menu-reducer&apos;;import msgMenuReducer from &apos;./msg-menu-reducer&apos;;const rootReducer = combineReducers(&#123; appMenu: appMenuReducer, msgMenu: msgMenuReducer&#125;);export default rootReducer; 在根元素的位置引入Provider12345678const createStoreWithMiddleware = applyMiddleware(promise)(createStore);ReactDOM.render( &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt; &lt;RouterMap /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)); 在组件中使用redux123456789101112131415161718192021222324import &#123; connect &#125; from &apos;react-redux&apos;;import &#123; bindActionCreators &#125; from &apos;redux&apos;;import &#123; getMsgMenu &#125; from &apos;../actions/index&apos;; // actioncomponentDidMount() &#123; // 修改和获取都是通过props完成 if (this.props.msgMenu.length === 0) &#123; // 获取store里的数值 axios.get(&apos;/api/snp/CRH-SNP5103&apos;).then((res) =&gt; &#123; this.props.getMsgMenu(res.resultList, 0); // dispatch 一个action &#125;); &#125;&#125;function mapStateToProps(&#123; msgMenu &#125;) &#123; return &#123; msgMenu &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; getMsgMenu &#125;, dispatch);&#125;// 通过HOC使SpecialMsg具有msgMenu, getMsgMenu(props);export default connect(mapStateToProps, mapDispatchToProps)(SpecialMsg); 写在最后 1 使用redux 2 了解redux原理 3 了解各个知识点 4 进阶了解中间件 5 不禁感慨学无止境,, 参考资料参考1参考2]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用模块封装代码]]></title>
    <url>%2F2017%2F12%2F07%2F%E7%94%A8%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[javascript用共享一切的方法加载代码，这样会造成一些命名冲突和安全问题。es6的一个目标就是解决作用域问题，为了javascript程序显得有序，引入了模块。 模块是自动运行在严格模式下并且没有办法退出运行的javascript代码。 模块的顶部，this的值是undefined 模块不支持html注释 模块的真正魔力在于导入与导出而不是将所有的东西放到一个文件中处理 导出文档说明1234567891011121314// 语法：export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …; 导入文档说明123456789101112// 语法：import defaultExport from &quot;module-name&quot;;import * as name from &quot;module-name&quot;;import &#123; export &#125; from &quot;module-name&quot;;import &#123; export as alias &#125; from &quot;module-name&quot;;import &#123; export1 , export2 &#125; from &quot;module-name&quot;;import &#123; export1 , export2 as alias2 , [...] &#125; from &quot;module-name&quot;;import defaultExport, &#123; export [ , [...] ] &#125; from &quot;module-name&quot;;import defaultExport, * as name from &quot;module-name&quot;;import &quot;module-name&quot;;// es6的import语句为变量、函数、和类创建的是只读绑定，因此引入一个变量时试图在这个模块中修改这个变量会报错。 无绑定导入 内建对象（如Array,Object）的共享定义可以在其它模块中访问，对这些对象所做的更改也将反应在其它模块中。无绑定导入通常被用在Polyfill和Shim. 12345678910111213// 向数组添加pushAll方法，放入example.js Array.prototype.pushAll = function(items) &#123; if(!Array.isArray(items)) &#123; throw new TypeError(&apos;参数必须是一个数组！&apos;); &#125; return this.push(...items); &#125; // 使用 import &quot;./example.js&quot;; let color = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]; items = []; items.pushAll(color); 加载模块在web浏览器中使用模块123456789&lt;!--加载一个javascript模块文件--&gt;&lt;script type=&quot;module&quot; src=&quot;module1.js&quot;&gt;&lt;/script&gt;&lt;!--内联引入一个模块--&gt;&lt;script type=&quot;module&quot;&gt; import &#123; export &#125; from &quot;module-name&quot;; export();&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;module2.js&quot;&gt;&lt;/script&gt; 在web浏览器模块的加载顺序使用模块化加载资源都是按需加载并执行的。 同步执行按照在文档中出现的顺序顺序执行。上面的案例代码执行顺序为 1 下载module1.js并解析2 递归下载并解析module1.js引入的资源3 解析内联模块4 递归下载并解析内联模块中引入的资源5 下载module2.js并解析6 递归下载并解析module2.js引入的资源 只有加载完成后才会执行其他操作，加载完成后 1 执行module1.js并解析2 递归执行module1.js引入的资源3 解析内联模块4 递归执行内联模块中引入的资源5 执行module2.js并解析6 递归执行module2.js引入的资源 异步执行123&lt;script type=&quot;module&quot; async src=&quot;module1.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; async src=&quot;module2.js&quot;&gt;&lt;/script&gt;// 上面的代码如果module1.js先下载完成（包括所有导入的资源），module1.js先执行。同样的module2.js也一样 浏览器模块说明解析符 以/开头的解析为从根目录开始。 以./开头的解析为从当前目录开始。 以../开头的解析为从父目录开始。 URL格式。 对es6模块化的理解copy react项目总结 理解初始于，这样的一段代码1234567891011121314151617181920import React, &#123; Component &#125; from &apos;react&apos;;let moduleList = [];class Message extends Component &#123; componentDidMount() &#123; ... &#125; componentWillUnmount() &#123; ... &#125; render() &#123; return ( &lt;div className=&quot;page page-msg&quot;&gt; ... &lt;/div&gt; ); &#125;&#125;export default Message; 在class外部定义的变量moduleList并不会被销毁，babel把一个个的实例变成了立即执行函数，查看babel编译后的文件可以看到该字段是闭包中的一个私有变量，由于在闭包中字段不会销毁并且能保留数据操作后的状态，同时也可以通过调用class中的方法来修改该字段。当然该字段也存在闭包所存在的方法，正确使用有助于提高代码的质量。同时想到那些require.js sea.js import export, jquery之类的处理方法为了不污染外部变量都采用了再立即执行的作用域内最终return对外公开的对象，通过该对象可以操作闭包中的方法和属性，达到一些代码封装和模块加载的功能 1234567891011121314// 测试(function() &#123; var _userId = 1; var exportTest = &#123;&#125;; function converter(userId) &#123; _userId = ++userId; return _userId; &#125; exportTest.getUserId = function() &#123; return converter(_userId); &#125; window.exportTest = exportTest;&#125; ());exportTest.getUserId()// 此时的user id 会不断增加，因为闭包中的私有变量不会被清除，除非exportTest = null,释放对闭包函数的引用 总结1 过程立即执行函数执行，同时export一个闭包函数，保存着对闭包的引用2 当执行exportTest.getUserId() 私有变量_userId被重新赋值，呈自增（空间从未被释放）3 exportTest = null，闭包中的变量引用，以及闭包函数被释放 其它感慨一下模块化的知识树1 了解用法2 了解在一些执行环境的中的执行顺序3 了解模块化实现的原理，从而就可以在一些方面中利用闭包的一些特性，相当有用4 和其他知识像结合，模块化中给一些基本的对象增加原型方法，实现方法共享5 了解不同的模块化库，以及一些模块化规范，还有实现方法哈哈，这样看来我还是个渣渣，:-D]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise学习]]></title>
    <url>%2F2017%2F12%2F06%2Fpromise%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习promise刚开始是相当痛苦的，抱着深入理解es6这本书就开始看promise是个什么东西，先读了事件和回调，并不知道promise存在的意义，读到串联promise我就放弃了，感觉学习这个知识一点也不开心，学起来也很费力。直到有一天学超分享了Promise.All()的方法，好像一下就顿悟了，js这个脚本语言根本就不会存在多线程这种概念，由于我们可以自定义promise类型，在then()方法中可以异步去执行一些逻辑，才知道promise用处不仅仅是在ajax外面new一个promise。promise其实很牛逼。 异步编程的几种情况promise的出现不是取代其他的异步编程写法，而是在一些情况下使用promise处理时可以方便一些。1 事件模式2 回调函数（ajax）3 定时器（setTimeout, setInterval）4 promise promise的生命周期pending-&gt;settledsettled包括Fulfilled和Rejected,对应then方法的then(resolve, reject);有些类似于ajax请求的过程，pending时并不知道什么时候会处理完成，当promise处理完成已有就会根据成功和失败执行相应的回调，不同的是，then方法可以链式调用。 promise的方法和原型方法// ====================创建未处理的Promise=====================1234567891011// 由于每次返回的都是Promise对象因此可以链式的调用下面的两个方法Promise.prototype.catch() // 传入两个方法，resolve, rejectPromise.prototype.then()let p = new Promise(function(resolve, reject) &#123; //... resolve(res); reject(err);&#125;);p.then();p.catch(); // ====================创建已处理的Promise=====================123456789101112131415161718192021// 创建一个已处理的promise，使用promise表示一个已知值，就可以直接使用下面方法创建已解决的promise。Promise.reject()Promise.resolve()//二者都是接受一个已知的值，并返回一个promise对象，因此该对象就可以链式调用了let p = Promise.resolve(42);p.then((res) =&gt; &#123; console.log(res); // 42&#125;);// Thenable 对象：有用then()方法，并接受resolve，reject作为参数的普通对象就叫做Thenable 对象let thenable = &#123; then: function(resolve, reject)&#123; resolve(42); &#125;&#125;// 通过调用Promise.resolve(),返回Promise对象。如果想Promise.resolve()传入一个promise对象，怎不会有任何变化let p = Promise.resolve(thenable);p.then(function(res) &#123; console.log(res); // 42&#125;); //=======================链式调用promise===================12345678910111 链式中没有return值调用then返回undefined2 链式中return值返回对应的值3 链式中return值返回Promise对象，then调用return中的Promisenew Promise((res) =&gt; &#123; res(123);&#125;).then((res1) =&gt; &#123; console.log(res1); if(res.error_no !== 0 ) &#123; return Promise.reject(); // return一个自定义的Promise.reject()，那么调用then()方法只能执行第二参数，实现一些特殊效果 &#125;&#125;).then(() =&gt; &#123;&#125;, ()=&gt;&#123;&#125;); //=======================相应多个promise===================12Promise.all() // 返回一个数组，对应相应的返回值。表示有一个执行成功就执行resolve，否则rejectPromise.race() //返回一个值，表示有一个执行成功就执行resolve]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 项目总结]]></title>
    <url>%2F2017%2F11%2F28%2Freact-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[格式规范1 将大部分的正则校验放入reg文件中，统一管理，方便复用2 将h5调用原生的方法统一放入util文件中，方便查看项目中都使用了哪些原生方法，同时可以达到复用的效果 使用正则匹配style中为px的数据由于消息的详情页可能来自后台录入，录入的文章包含一些样式，由于项目中使用了flexible，使用px组件的显示都比较小，比较方便的方式就是通过正则匹配123456789pxToRem: function(_s)&#123; //匹配:20px或: 20px不区分大小写 var reg = /(\:\s*)+(\d)+(px)/gi; let newStr= _s.replace(reg, function(_x)&#123; _x = _x.replace(/(\:|: )/,'').replace(/px/i,''); return ':' + (parseFloat(_x) * 2 / 75).toFixed(5) + 'rem'; &#125;); return newStr;&#125; 在一些安卓手机中border不显示由于1px转换为rem后可能只有0.01，数值过小导致边框显示不出，1 大多数的处理方法是不对1px的边框进行转换 postcss-pxtorem 文档说明 A message about ignoring properties 12345678910// `px` is converted to `rem`.convert &#123; font-size: 16px; // converted to 1rem&#125;// `Px` or `PX` is ignored by `postcss-pxtorem` but still accepted by browsers.ignore &#123; border: 1Px solid; // ignored border-width: 2PX; // ignored&#125; 2 7 种方法解决移动端 Retina 屏幕 1px 边框问题 对js模块化理解增强理解初始于，这样的一段代码1234567891011121314151617181920import React, &#123; Component &#125; from &apos;react&apos;;let moduleList = [];class Message extends Component &#123; componentDidMount() &#123; ... &#125; componentWillUnmount() &#123; ... &#125; render() &#123; return ( &lt;div className=&quot;page page-msg&quot;&gt; ... &lt;/div&gt; ); &#125;&#125;export default Message; 在class外部定义的变量moduleList并不会被销毁，babel把一个个的实例变成了立即执行函数，查看babel编译后的文件可以看到该字段是闭包中的一个私有变量，由于在闭包中字段不会销毁并且能保留数据操作后的状态，同时也可以通过调用class中的方法来修改该字段。当然该字段也存在闭包所存在的方法，正确使用有助于提高代码的质量。同时想到那些require.js sea.js import export, jquery之类的处理方法为了不污染外部变量都采用了再立即执行的作用域内最终return对外公开的对象，通过该对象可以操作闭包中的方法和属性，达到一些代码封装和模块加载的功能 1234567891011121314// 测试(function() &#123; var _userId = 1; var exportTest = &#123;&#125;; function converter(userId) &#123; _userId = ++userId; return _userId; &#125; exportTest.getUserId = function() &#123; return converter(_userId); &#125; window.exportTest = exportTest;&#125; ());exportTest.getUserId()// 此时的user id 会不断增加，因为闭包中的私有变量不会被清除，除非exportTest = null,释放对闭包函数的引用 总结1 过程立即执行函数执行，同时export一个闭包函数，保存着对闭包的引用2 当执行exportTest.getUserId() 私有变量_userId被重新赋值，呈自增（空间从未被释放）3 exportTest = null，闭包中的变量引用，以及闭包函数被释放 对ref的理解1 复杂组件可以获取对外的一些属性和方法2 简单的可以获取一个dom节点 高阶组件，及高阶组件生命周期生命周期滚动加载组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; Component &#125; from &apos;react&apos;;let timer = null;class LoadingMore extends Component &#123; constructor(props) &#123; super(props); this.scroll = this.scroll.bind(this); &#125; scroll() &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; console.log(&apos;scrolling&apos;); const loadMoreFn = this.props.loadMoreFn || function () &#123;&#125;; const loadingDom = this.refs.loading; const loadingDomTop = loadingDom.getBoundingClientRect().top; const windowHeight = window.innerHeight; if (loadingDomTop &amp;&amp; loadingDomTop &lt; windowHeight) &#123; loadMoreFn(); &#125; &#125;, 100); &#125; componentDidMount() &#123; const pageContent = document.querySelector(&apos;.page-content&apos;); if (pageContent) &#123; pageContent.addEventListener(&apos;scroll&apos;, this.scroll, false); &#125; else &#123; window.addEventListener(&apos;scroll&apos;, this.scroll, false); &#125; &#125; componentWillUnmount() &#123; console.log(&apos;window removeEventListener&apos;); const pageContent = document.querySelector(&apos;.page-content&apos;); if (pageContent) &#123; pageContent.removeEventListener(&apos;scroll&apos;, this.scroll, false); &#125; else &#123; window.removeEventListener(&apos;scroll&apos;, this.scroll, false); &#125; timer = null; &#125; render() &#123; return ( &lt;div className=&quot;loading-component&quot; ref=&quot;loading&quot;&gt; &lt;div&gt; &lt;span className=&quot;font&quot;&gt;加载中...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default LoadingMore; 优化，滚动至底部是显示没有更多数据 webpack神器配制：devtool: ‘source-map’, 结合react插件就可以打断点了 思想转变由于惯性思维，设置一些status时，只想到通过两种状态如何控制视图的显示。有时候一些逻辑只用true或者false两种状态是不够的，可以使用status（1,2,3…） 在入口页面判断是否登录之前错误的处理逻辑为，把入口页面index作为一个容器，根据情况平判断加载login页面还是首页，这样操作的问题是，在同一个页面中处理两套生命周期比较是比较复杂的1 render先执行根据默认值会加载login页面2 当didmound中拿到登录状态发现已经登录，再去加载首页 处理：在没有拿到登录状态时先不渲染，拿到登录状态了，如果用户已经登陆在入口页加载首页，如果没有直接跳转至登录页面 ios fix 布局由于position: fixed在ios中存在的问题较大，使用了相对定位做了替代 页面结构修改由于ios对fix属性支持的不好，因此用absolute来替换需要处理的内容，如果不需要顶部固定可以做不处理1 顶部标题栏（header）和页面内容（page-content）和页脚（footer）为并列关系，被page包含，都是用绝对定位2 页面内容（page-content）需要设置为纵向滚动，据顶部的距离为头部的高度3 此时的滚动加载更多的组件滚动区域不是相对于window而是page-content4 需要定位的固定在底部的元素可以在page-content外面绝对定位，需要区别个别手机键盘将文字顶起的情况,还有滚动一段距离固定的问题 低版本手机中不支持setreact 16 依赖 Set、Map、requestAnimationFrame，如果在不支持的浏览器请使用 pollyfil,处理这个问题的时候怂了，由于不清楚react16还有什么坑，我把版本设为了15.6。 h5资源本地化的理解就是将我们的部分文件放在手机内存中，目前的app仅有10M,由于菜单等信息都是接口获取的，暂时没有考虑资源本地化 react路由以及props改变时触发的触发的钩子函数 componentWillReceivePropsReact router 4 带参数的路由，从”/album?id=1”访问”/album?id=2”该如何重新渲染？ 还是第一次在sf上回答，有点小激动，嘻嘻~ jsx语法遍历对象通过Object.keys(obj)来将对象转成数组，再用map去处理，其中需要注意的是，jsx语法中render的是一个对象他只会对这个对象执行，render一个组件才会被渲染在是视图中eg:{&lt;component /&gt;} // 不会被渲染&lt;component /&gt; // 会渲染 require的神奇情况require在一些情况下直接读一个变量会报错，如果这样写require(‘../abc’+data)才可以，很神奇，情况不明 待处理1 对应一个分页的页面，滚动一定的距离，进入详情页面，再返回的时候，列表页中滚动条的位置不应该被初始化到顶部2 对于项目中的四个tab也，每次切换的时候都会有接口调用，会出现屏闪的问题，页面优化]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js作用域]]></title>
    <url>%2F2017%2F10%2F10%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[javascript 作用域全局作用域 全局函数声明，if,for,while中定义的函数都属于全局作用域 函数作用域 函数有自己的作用域,因此会有以下来定义局部作用域 123456// 匿名函数被认为是表达式(function() &#123;&#125;)()!function() &#123;&#125; ()+function()&#123;&#125;();(function()&#123;&#125;());var a = function() &#123;return s&#125;(); 函数声明和变量声明会被前置 12345var myvar = &apos;my value&apos;; (function() &#123; alert(myvar); var myvar = &apos;local value&apos;; &#125;)(); 变量声明前置缺省值为undefined 名称解析顺序： 1 当前作用域内是否有 var foo 的定义。 2 函数形式参数是否有使用 foo 名称的。 3 函数自身是否叫做 foo。 4 回溯到上一级作用域，然后从 #1 重新开始。 命名空间 通过立即行函数实现，因为函数拥有自己的作用域。通过这种方式可以避免变量污染 12345678910(function() &#123; // 函数创建一个命名空间 var $ = &#123;&#125;; $.foo = function() &#123; console.log(1) // 对外公开的函数，创建了闭包 &#125;; window.$ = $;&#125;)(); // 立即执行此匿名函数 eval作用域 eval(‘var a = 1;’),由于不建议使用eval，暂不研究 es6箭头函数作用域es3执行作用域 执行上下文 Execution Context 简称ec 变量对象(VO) 抽象概念主要包括（变量， 函数声明， 行数参数） 活动对象(AO) 执行上下文概念： 是一个抽象概念，函数执行前创建，将一系列活动组成一个栈栈底总是全局执行山下文，栈顶总是当前执行上下文]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的工作原理]]></title>
    <url>%2F2017%2F10%2F10%2Fthis%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[this有一下五种指向1 全局范围内的this，指向全局对象2 function中的this，指向全局对象3 方法中的this,指向当前对象4 通过new关键字生成的，指向新生成的对象5 通过call, apply, bind方法时，函数的this指向第一个参数 参考页面，js秘密花园]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F10%2F09%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包定义 有权访问另一个函数作用域的变量的函数 闭包不同于一般的函数，它允许立即词法作用域外调用时仍可访问本地变量 通常这样定义： 12345678function outerFn() &#123; var a = 30; return function() &#123; return a; &#125;&#125;var outer = outerFn(); 闭包表现形式 1 在一个函数中return另一个函数 2 定时器，setTimeout，setInterval 3 addEventListener 4 $.ajax等 12345678910111213141516171819// 闭包无处不在，使用闭包的举例,可以比较方便的访问局部变量!function() &#123; var localData = &quot;localData&quot;; document.addEventListener(&apos;click&apos;, function() &#123; console.log(localData); &#125;);&#125;();!function() &#123; var localData = &apos;localData&apos;; var url = &apos;htp://www.baidu.com&apos;; $.ajax(&#123; url: url, success: function() &#123; // do something console.log(localData); &#125; &#125;);&#125;() 理解闭包，及闭包带来的问题 123456789101112131415161718192021222324252627282930// 示例1function a() &#123; var res = []; for(var i=0; i&lt;10; i++) &#123; res[i] = function() &#123; return i; &#125; &#125; return res;&#125;a() // 一个包括10个函数引用的数组a()[0]() // 10a()[1]() // 10// 示例2for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); // 10 &#125;, 1000);&#125;// 示例3function b()&#123; document.body.innerHTML = &apos;&lt;div id=div1&gt;aaa&lt;/div&gt; &lt;div id=div2&gt;bbb&lt;/div&gt; &lt;div id=div3&gt;ccc&lt;/div&gt;&apos;; for(var i=1; i&lt;4; i++) &#123; document.getElementById(&apos;div&apos;+i).addEventListener(&apos;click&apos;, function() &#123; alert(i); &#125;) &#125;&#125; 上面的三种都为闭包的表现形式，他们有共同的特点。都是分两步执行的，1 执行外部函数（或语句），2 执行闭包内函数。 第一个函数执行a(),返回一个数组，数组元素为一个个的函数引用，当执行a()[0],此时for循环已经执行完毕了，因此结果为10 第二个语句内部为定时器，定时器本身就是异步的，for循环先执行，当定时器函数执行的时候i已经为10了。 第三个函数内部为事件绑定，当只有触发click时间的时候才去打印i,此时的i已经是for循环最终执行的值了。 解决这些问题的方法：可以在闭包函数外层包一层立即执行函数，并给立即执行函数添加形参。 12345678910function fn2()&#123; document.body.innerHTML = &apos;&lt;div id=div1&gt;aaa&lt;/div&gt; &lt;div id=div2&gt;bbb&lt;/div&gt; &lt;div id=div3&gt;ccc&lt;/div&gt;&apos;; for(var i=1; i&lt;4; i++) &#123; !function(mun) &#123; document.getElementById(&apos;div&apos;+mun).addEventListener(&apos;click&apos;, function() &#123; alert(mun); &#125;) &#125;(i); &#125;&#125; 使用闭包封装代码 123456789101112131415161718192021(function() &#123; var _userId = 23554; var _typeId = &apos;item&apos;; var exportTest = &#123;&#125;; function converter(userId) &#123; return +userId; &#125; exportTest.getUserId = function() &#123; return converter(_userId); &#125; exportTest.getTypeId = function() &#123; return _typeId; &#125; window.exportTest = exportTest;&#125;());exportTest.getUserId();exportTest.getTypeId(); 释放引用对象，来释放空间 由于闭包会保持对外部函数的引用，会一直占用空间，造成内存泄漏 123456function a() &#123; var b = 1; return function() &#123; console.log(b++) &#125;&#125; var c = a(); c()// 1,第二次执行打印2,依次加一,, c = null; // 解除对匿名函数的引用，这样对变量b的引用就会结束 其它 使用作用域链去解释闭包。（闭包活动对象-》函数活动对象-》全局变量对象）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2017%2F10%2F08%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型链构造函数，原型对象，实例关系：每个构造函数都有一个原型对象，原型对象对象包含指向构造函数的指针，每个实例都包含指向原型对象的内部指针。当把一个实例赋值给一个原型对象的时候，原型对象-》实例-》该实例的原型对象（从而获取该实例的属性方法），原型的查找顺序也是(原型对象-》实例-》该实例的原型对象)从左向右查找的。1Sub.prototype = new sup(); 1 默认的原型为Object，因此每个对象都会有hasOwnProperty, isPropertyOf, toString等方法2 确定原型与实例的关系可以根据 instanceof Person.prototype.isPropertyOf(p1) 判断3 注意定义方法的顺序，给原型添加的方法一定要放在替换原型的语句之后4 原型链的问题：和原型一样，引用类型的数据会被所有实例共享。 借用构造函数（constructor stealing）借用构造函数就是通过call,apply的方式将另一个的构造函数当做自己的函数体1234function sup() &#123;&#125;function sub() &#123; sup.call(this);&#125; 这种方式很少单独使用，无法避免构造函数模式存在的问题 特点可以在子类的构造函数中给超类的构造函数传递参数 组合继承组合继承 = 原型链 + 借用构造函数模式1234567function sup() &#123;&#125;function sub() &#123; sup.call(this);&#125;sub.prototype = new sup();sub.prototype.constructor = sub;... 融合了两种模式的优点，是最常用的继承模式 原型式继承1234567function object(o) &#123; // o必须为一个对象 function F() &#123;&#125;; F.prototype = o; return new F();&#125;// es5规范了原型式继承Object.create(o); 寄生式继承在原型式继承的基础上继续加工的结果12345function Test(o) &#123; var clone = object(o); clone.sayHi = function() &#123;&#125; return clone;&#125; 寄生组合继承在原型，原型链笔记文章中有案例通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。将sub.prototype = new sup()替换为了object(sup.prototype),省去了一次构造函数的调用（可是增加了new F() ..） 备注理解这些概念的时候本身就比较生硬，考虑问题的时候需要过滤掉一些干扰性的元素，考虑要考虑的问题本身。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6 函数总结]]></title>
    <url>%2F2017%2F10%2F07%2Fes6-%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[es6增加了很多语法糖，比如增加了一些方便判断的属性，写法上更加简单了 函数形参的默认值 形参默认值，即定义函数的时候可以给形参赋值，赋值的内容可以是常量，变量，表达式 需要注意的是： 1 默认值对arguments对象有影响 2 默认参数的临时死区 处理无命名参数 由于javascript函数的参数想传多少就传多少，之前会使用arguments对象处理无命名，现在可以使用...arg方式替代 注意 1 不定参后面不能有其他参数 2 不定参不能用于对象字面量setter中，因为setter中的参数有且只有一个 3 无论是否有不定参，arguments对象总是包含所有传入的参数 增强function构造函数 function构造函数，几乎没有用过… 12// 使用案例var add = new function(&apos;first&apos;, &apos;second=1&apos;, &apos;return first + second&apos;); 展开运算符 这是一个语法糖，嘿嘿，和不定参很像，不定参可以让各自独立的一些参数最终以数组的方式访问，展开运算的则是将数组打乱成各自独立的参数 1234567Math.max(25, 50, 70, 100);// 同样写法let val = [25, 50, 70, 100];Math.max(...val);也支持这种写法Math.max(...val, 101); name属性 Function.name, 方便开发者追踪栈记录 函数的多重用途用途 1 和new一起使用作为构造函数 内部调用[[Constructor]] 2 函数使用 内部调用[[Call]] 判断函数是否作为构造函数在使用 es5 p1 instanceof Person 但是无法区分是通过Person.call()还是new关键字得到的实例 es6 通过new.target来判断 当调用函数的[[Constructor]]方法时，会为new.target赋值new操作符的目标，通常为new时候的构造函数，如果函数调用的是[[Call]],new.target则为undefined // 通过new关键字创建 eg: typeof new.target !== “undefined” 块级函数 es5严格模式下，在代码块中声明函数会报异常，而在es6中作为一个块级声明（严格模式），在作用域内可以使用，一旦代码块执行完毕后，函数也结束了，非严格模式下会被提升至外围函数或者全局作用域中 块级函数与let函数表达式类似，区别为块级函数会被提升至块的顶部，let 函数表达式不会 箭头函数 箭头函数很像c#中的lambda表达式 特点 1 没有 this, super, arguments, new.target的绑定，这些都由外围最近一层的非箭头函数决定 2 不能通过new关键字调用 3 没有原型 4 不可改变this的绑定 5 不支持arguments对象 6 不支持重复的命名参数 语法 12345678910111213141516171819let doNothing = () =&gt; &#123;&#125;; // 创建空函数let getName = () =&gt; Nicholas;// 无参let reflect = value =&gt; value;// 一个参数let sum = (num1, num2) =&gt; num1+mum2; // 多个参数，一个表达式的函数体let sum = (num1, num2) =&gt; &#123; // 多个参数，由多个表达式组成的函数体 return num1+mum2;&#125;;// 如果返回结果是对象，需要将该字面量包在`()`中,这样是为了与函数体区分let getTempItem = id =&gt; (&#123;id: id, name: &apos;temp&apos;&#125;);//创建立即执行函数let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; return name; &#125; &#125;&#125;)(&apos;Nicholas&apos;); 其它 1 简化sort,map,reduce的写法，eg: values.sort((a, b) =&gt; a-b) 2 在箭头函数上调用apply, call, bind和普通函数类似，只是箭头函数中的this不会受这些方法的影响 尾调用优化 系统引擎优化 123function a() &#123; return b(); // 尾调用&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局: 元素的摆放方式displaypositionfloatflex display 实现同行显示或者换行显示 block（p, h1, ul, form） 和margin: 0 auto 组合使用，居中显示 inline(span, a, label) inline-block(input, textarea, select, button) 和inline比起来，内容换行后占据宽度剩下的空间 和 vertical-align: middle 实现垂直居中 none display: none VS visibility: hidden visibility 元素仅仅是隐藏，占据原来的空间 position 定位top, bottom, left, right, z-index同时设置top, bottom, left, right会将元素撑开 z-index 栈, 因此z-index大的不一定就显示在上面 static|relative|absolute|fixed relative仍在文档流中参照物为元素本身 absolute默认宽度为内容宽度，可以通过width:XX，设置宽度设置高度可能需要使用top: XX; bottom: XX;通过使用固定定位可以方便的实现顶部栏固定，内容区域滚动脱离文档流参照物为第一个定位祖先/视窗（包含块/初始包含块–padding-edge）https://segmentfault.com/a/1190000009661604 fixed默认宽度为内容宽度脱离文档流参照物为视窗 ios中会存在一些问题，存在原因？解决方式？问题，解决方案iscroll库引入动态改变position的值，改为static floatleft right none默认宽度为内容宽度半脱离文档流（对元素，托利文档流，对内容，在文档流）会向指定方向一直移动 clear [both|left:right|none|inherit]应用于后续元素应用块级元素清除浮动的方法：增加空白元素，设置class{display: block; clear: both; }在浮动元素的父元素添加clearfix.clearfix:after { content: ‘.’; display: block; clear: both; height: 0; overflow: hidden; visibility: hidden;} flexflex-grow: 拉伸flex-shrink: 收缩 其它实现左右布局的方式absolute+margin-leftfix+margin-leftfloatflex 顶部固定，底部固定布局position: fixed固定，使用padding-bottom和padding-top控制上下间距。 走马观花的耕了一遍..感觉没有多少成就感，呜呜 ~~(&gt;_&lt;)~~ 以后有收获再来升级这篇文章吧..]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象描述： 无序的key,value键值对 整个对象发展的过程： ——》先是有个new一个对象的写法 简化写法 ——》对象字面量（可以使用对象写法） 批量生产 ——》工厂模式（new Object） 区别自定义对象类型 ——》构造函数类型（可以new 自定义类型, 构造函数定义来了） 解决函数类型实例化造成的空间浪费 ——》原型模式（出现原型对象） 原型对象为实例共享，引用类型修改时会对其它实例造成影响 ——》组合使用构造函数原型模式（1+1 = ？） … 一系列的相关的问题 this指向，改变this指向的途径，作用域，识别实例来自哪个构造函数，对象看成一个key,value列表因此出现元素遍历,区别实例属性原型链属相-&gt;for in-&gt;.. 创建自定义对象 对象字面量 123456789var person = &#123; name: &apos;aa&apos;, age: 18&#125;Object实例创建var person = new Object();person.name = &apos;aa&apos;;person.age = 18; 属性 数据属性 访问器属性： 封装一些组件时一些高级用法时使用 工厂模式 12345678function createPerson(name, age) &#123; var o = new Object(); o.name = name; o.age = age; return o;&#125;var p1 = createPerson(&apos;abc&apos;, &apos;16&apos;); 解决构造函数或者对象字面量重复的问题，就好比一个蛋糕模子，每次创造出一模一样的东西，缺点：无法区别这些蛋糕（没有解决对象的识别问题） 构造函数模式 与工厂模式比较有点是可以将实例识别为某一种特定的类型 为了区别构造函数和普通函数构造函数首字符大写，构造函数本质就是普通函数，当使用关键字new的时候会产生神奇的变化 1 创建新对象 2 将构造函数的作用域赋值给新对象（this指向改变） 3 执行构造函数的代码（为新对象添加属性） 4 返回新对象 123456function Person(name, age) &#123; this.name = name; this.age = age; console.log(1);&#125;var p1 = new Person(); 缺点：属性为function类型时，多次创建实例的同时也会创建多个function实例 原型模式 原型模式需要理清 构造函数，实例，原型对象之间的关系 1 理解原型对象 每个函数都有prototype属性，存储了原型对象。创建原型对象后会自动获取constructor属相，其余属性都是从Object上继承而来 方法： 12345678910111213141516function Person() &#123;&#125;Person.prototype.name = &apos;name&apos;;Person.prototype.age = &apos;agePro&apos;;var person1 = new Person();person1.age = &apos;age&apos;;Person.prototype.isPrototypeOf(person1)// true;// 返回原型链上的值Object.getPrototypeOf(person1);// 使用delete可以删除实例属性，那么就可以正常获取原型属性了delete person1.age// hasOwnProperty,判断属相是否为实例属性person1.hasOwnProperty(&apos;age&apos;) //boolean 原型与in操作符 in 两种使用方式 单独使用/ for in 循环 for in循环可以遍历可枚举的属性，因此位于原型或者实例的都可以扫描到 in 使用 1234567891011&quot;age&quot; in person1// 判断属相属于实例还是原型：function hasPrototypePropertype(obj, name) &#123; return !obj.hasOwnProperty(name) &amp;&amp; (name in obj);&#125;// Object添加keys()属性，返回所有可枚举的属性（字符串数组）Object.keys(person1)// 返回所有属性，包括不可以枚举属性Object.getOwnPropertyNames(person1)Object.getOwnPropertyNames(Person.prototype) 更简单的原型语法 123456789function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 需要添加这个，否则constructor指针将不指向person，重新设置constructor属性会导致该属性标记为可枚举类型，不过可以重新定义为definePropoty(Person.prototype, &apos;constructor&apos;, &#123; enumerable: false, value: Person &#125;) name: &apos;name&apos;, age: &apos;age&apos;&#125; 原型的动态性 1234567891011121314function Person() &#123;&#125;var p2 = new Person();Person.prototype = &#123; constructor: Person, name: &apos;name&apos;, age: &apos;age&apos;&#125;p2.age // undefinedfunction Person() &#123;&#125;var person1 = new Person();Person.prototype.name = &apos;name&apos;;Person.prototype.age = &apos;agePro&apos;;person1.age; // agePro 原生对象的原型 所有原生的引用类型都是通过原型模式创建的，他们都在构造函数的原型上添加了方法，因此可以给这些原生对象添加原型属性，这样不好，， 原型对象的问题 实例可以更改引用类型的属性，导致其他的实例受影响 组合使用构造函数原型模式 没啥好说的，结合了两种模式的优点，是使用最广泛的模式了 动态原型模式 模仿其他oop语言，将所有信息封装在构造函数中。增加if判断语句，在执行构造函数时初始化实例方法。 寄生构造函数模式 和工厂模式一样，除了实例化时使用了new关键字调用构造函数,在某些特殊情况使用，比如创建一个具有额外方法的数组。 12345678function createPerson(name, age) &#123; var o = new Object(); o.name = name; o.age = age; return o;&#125;var p1 = new createPerson(&apos;abc&apos;, &apos;16&apos;); 稳妥构造函数模式 和寄生构造函数类似，不同的是： 1 构造函数中不能使用this；2 不能用new关键字调用构造函数； 3 可以定义私有变量，不能通过实例直接访问属性，有点像oop中的私有属性，哭，， 1234567891011function createPerson(name) &#123; var o = new Object(); // 可以定义私有变量 o.sayName = function() &#123; alert(name) &#125; return o;&#125;var p1 = createPerson(&apos;abc&apos;);p1.sayName();// 只能通过调用sayName方法访问属性。 问题 操作符 in typeof instanceof delete Object 好神奇 Function.prototype.[call|aplly|bind|isGenerator|toSource|toString] bind：改变this指向，不执行函数体，返回改变this后的函数引用 call,apply: 改变this指向，执行函数体，返回执行结果 12345678910111213141516this.x=10;var obj = &#123; x: 100, num: function(desc) &#123; console.log(desc+this.x) &#125;&#125;obj.x; // 100obj.num(&apos;d&apos;); // 100var b = obj.num;// 此刻的this为函数的this，指向全局b(&apos;e&apos;); // 10var b2 = b.bind(obj,&apos;a&apos;);b2(&apos;f&apos;); // 100var b3 = b.call(obj, &apos;b&apos;) // 100var b3 = b.apply(obj, [&apos;c&apos;]) // 100 this指向 new一个对象都做了什么 constructor属性指向构造函数,作用？ https://segmentfault.com/q/1010000000347868 函数作用域，函数的this指向 作用域（函数作用域，全局作用域，es6块作用域） 好像没有删除原型属性的方法 参考网站]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2017%2F09%2F29%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[总结选择器感觉就是像在记流水账，，，不过css的选择器功能确实挺强大的，有些匹配和正则的匹配方式是一致的，有些是css3新增的，旧版本的浏览器可能会不支持，可以通过caniuse网站来查看兼容性。 详细脑图 css历史 css1 1996 css2 1992 css2.1 2007 css3 2001-. 外部文件引入方式 &lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot;&gt;&lt;/link&gt; 浏览器私有属性 chrome，safari -webkit- firefox -moz- IE -ms- opera -o- 语法 注释 /**/ 选择器 { 属性声明 } 属性声明=属性名：属性值 属性值语法： margin:[||auto]{1,4} 基本元素 组合符号 数量符号 基本类型 关键字, 类型, 符号（/,）, inherit, initial 组合符号 空格（必填，顺序有关） &amp;&amp;（必填，顺序无关，） ||（至少出现一个） | （只能出现一个） [] 分组 数量符号 无 + 可以出现一次货多次 ? 可出现也可以不出现 {2,4} * # 一次或者多次 规则语法 @标示符 xxx; @ 标示符 {} 规则 @media @keyframes @font-face @import 选择器 ID选择器 类选择器 标签选择器 *通配符选择器 属性选择器 12345678[attr][attr=&quot;val&quot;] 表示val中包含符号或者空格[attr=val] #nav&#123;&#125; == [id=nav]&#123;&#125;[attr~=val] .sport&#123;&#125; == [class~=sports]&#123;&#125;，可用于除了class以为的其它属性[attr|=val] 特定属性选择器，一般用于匹配属性lang的值[attr^=val][attr$=val][attr*=val] 伪类选择器 1234567891011121314151617181920a:linka:visiteda:hovera:active:enabled, disabled, checked:only-child:first-child:last-child:nth-child(even|odd):nth-child(n+1):nth-last-child(n+1)dd:first-of-type&#123;&#125;(同上):empty:root:not eg: :not(p)选择非p元素:target:lang() 伪元素选择器 123456(应用在元素内容的选择器)在css3中为了区别伪元素和伪类在前面添加::::first-letter::first-line::before (和content一起使用)::after::selection 组合选择器 1234567后代选择器.main h2子选择权.main&gt;h12兄弟选择器h2+p(获取前面为h2的一个p元素)h2~p(获取前面为h2的所有兄弟) 选择器分组 h1,h2,h3... css优先级 !important a = 行内样式 1000 b = ID选择器的数量 100 c = 类、属性选择器的数量 10 d = 标签选择器和伪元素选择器的数据量 1 兼容性测试网站 https://www.quirksmode.org/css/ http://caniuse.com/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国金项目总结]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%9B%BD%E9%87%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node地址转发 方案一种使用由于请求地址不同源存在跨域问题，因此使用使用node地址进行了一次转发 123456789101112131415161718192021222324'use strict';const path = require('path');const express = require('express');const proxy = require('express-http-proxy');const proxyUrl = 'https://webapps.yongjinbao.com.cn';const app = express();app.use(express.static(__dirname));app.use('/api', proxy(proxyUrl, &#123; // 当访问含有/api的地址时做转发处理 proxyReqPathResolver: (req) =&gt; &#123; return require('url').parse(req.url).path; &#125;&#125;));app.use('*', function (req, res)&#123;// 项目启动后加载的页面 res.sendFile(path.resolve(__dirname, 'fund.html'));&#125;);app.listen(8880, () =&gt; &#123; console.log('App is running on port 8880');&#125;); 数据逻辑处理（同步以及异步处理） 方案二，由于客户端不能对接口进行转发，数据仅存在服务器的静态文件中，使用了一种类似于jsonp的请求方式，但不是jsonp,即在静态文件中将所有的数据放在一个变量中。前端通过动态的add &lt;script&gt;标签的方式获取在静态文件中定义的变量取值。数据分四次获取，每个文件50条，滚动分页的方式加载数据，每次加载10条实现思路将异步和同步数据的处理逻辑分开写。可能遇到的滚动时获取异步数据时可能取不到，需要添加一个flag标志，当数据获取以后再去做数据渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 动态加载scriptfunction loadScript(url,callback) &#123; var script = document.createElement('script'); script.type = 'text/javascript'; script.async = 'async'; script.src = url; document.body.appendChild(script); script.onload = function()&#123; callback(); &#125;&#125;// 分情况加载数据function getNews(news_page_num, page_num, isGetScript) &#123; newsLoading = false; var newsData = []; if (isGetScript) &#123; loadScript('https://devtest.yjbtest.com/gjzqwxtest3g/information/data/newsData'+news_page_num+'.json', function() &#123; newsLoading = true; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; renderNews(newsData.slice(0,10)); &#125;); &#125; else &#123; newsLoading = true; var data = []; switch (news_page_num) &#123; case 1: newsData = window.newsData1; break; case 2: newsData = window.newsData2; break; case 3: newsData = window.newsData3; break; default: newsData = window.newsData0; break; &#125; switch (page_num%5) &#123; case 2: data = newsData.slice(10,20); break; case 3: data = newsData.slice(20,30); break; case 4: data = newsData.slice(30,40); break; case 0: data = newsData.slice(40,50); break; &#125; renderNews(data); &#125;&#125; 无限滚动 监听window的scroll事件，在页面的底部放一个loading的div，当滚动事件触发的时候判断loading div据顶部高度是否小于当前文档的高度，如果小于那么loading div就已经展示在页面中了，那么去进行数据获取防止数据请求过于频繁添加了一个定时器在页面数据加载完成的时候移除滚动事件 123456789101112131415161718192021222324252627282930313233window.addEventListener('scroll', scrollLoad, false);function scrollLoad() &#123; if (scrollTimer) &#123; setTimeout(scrollTimer); &#125; scrollTimer = setTimeout(function()&#123; var loadingDom = document.querySelector('.scroll-stance-element'); var loadingDomTop = loadingDom.getBoundingClientRect().top; var windowHeight = window.innerHeight; if (loadingDomTop &amp;&amp; loadingDomTop &lt; windowHeight) &#123; if ($('.new-con-tpl .block').length &lt; 200) &#123; if (!newsLoading) &#123; return; &#125; if (pageNum%5 == 0) &#123; newsPageNum++; &#125; pageNum++; if (pageNum%5 == 1) &#123; getNews(newsPageNum, pageNum, true); &#125; else &#123; getNews(newsPageNum, pageNum); &#125; &#125; else &#123; $('.scroll-stance-element').addClass('hidden'); $('.new-nomore').removeClass('hidden'); window.removeEventListener('scroll', scrollLoad, false); &#125; &#125; &#125;, 100);&#125; 根据屏幕宽度对字符串动态进行截取 截取字符串计算文档的宽度获取当前的字号计算当前可以容纳的字数 进入其他项目咨询页面配置页面路由 由于需要跳转至另一个framework7项目中，因此配置了相关的进入页面的路由 1234567// 获取url里的信息function getQueryValue(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null)return unescape(r[2]); return null;&#125; jsonp和直接引入静态js文件(理解jsonp)本次中由于只有静态文件，本次以引入文件的方式，在文件加载完成的时候获取约定的变量的方式获取和引入本地文件一样的道理比较通俗易懂的方式理解jsonp: http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 其它文档加载的两个函数DOMContentLoaded， load 在chrome network面板中可以很清新的看到DOMContentLoaded页面基本结构加载完成后显示完成时间。和jquery中的$(function(){})一致当初始HTML文档已完全加载和解析时，将触发DOMContentLoaded事件，而无需等待样式表，图像和子框架完成加载。——MDNhttps://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded 1234567document.addEventListener("DOMContentLoaded", function() &#123; // ...代码...&#125;, false);// DOMContentLoaded$(document).ready(function() &#123; // ...代码...&#125;); load页面完全加载显示完成时间 当一个资源及其依赖资源已完成加载时，将触发load事件。 ——MDN 123456window.addEventListener("load", function() &#123; // ...代码...&#125;, false);$(document).load(function() &#123; // ...代码...&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型，原型链笔记]]></title>
    <url>%2F2017%2F06%2F30%2F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解原型，原型链需要了解 原型对象 构造函数 实例三者之间的关系 原型 每个对象(Person)都会有一个原型对象，对象的实例(p1)包含一个隐式的指针指向原型对象 p1.propo === Person.prototype 原型链 如图所示 存在一个对象Student，想拥有Person的一些属性和方法，那么Student.proportype = new Person();那么new Student（）的实例就会存在Student 存在一个隐士指针指向Student的原型对象，而Student的原型指向了person的原型，由于所有自定义对象都是从Object对象继承来的，那么person的原型有指向了Object的原型 总结（摘自红宝书，第6章） 1 原型链之间为引用关系，因此对象实例共享所有的属性和方法，在原型链中的引用类型，因此不适宜单独使用，解决这个问题是利用构造函数，在子类构造函数的内部调用超类的构造函数(Person.call(this, name,,))，这样可以做到每个实例都具有自己的属性，同时还能保证只是用构造函数模式来定义类型。 2 对象可以在编码执行过程中创建和增强，因此具有动态性而非严格定义的实体。 1234567891011121314151617181920212223242526272829303132function object(o) &#123; function f() &#123;&#125;; f.prototype = o; return new f();&#125;function inher(sub,sup)&#123; var prototype = object(sup.prototype); // 创建对象 prototype.constructor = sub; // 增强对象 sub.prototype = prototype; // 指定对象&#125;function sup(name) &#123; this.name = name; this.color = ['blue','red']&#125;sup.prototype.sayName = function() &#123; console.log(this.name)&#125;function sub(name,age) &#123; sup.call(this, name); this.age = age;&#125; inher(sub,sup);sub.prototype.sayAge = function() &#123; console.log(this.age);&#125;var s1 = new sub() 其它一个不错的在线编辑绘制图片工具：processon在问答网站回答问题可以促使去各处查资料，优化表达，学习更全面的知识]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现列表标题标题头第一列最后一列固定]]></title>
    <url>%2F2017%2F05%2F24%2F%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E6%A0%87%E9%A2%98%E6%A0%87%E9%A2%98%E5%A4%B4%E7%AC%AC%E4%B8%80%E5%88%97%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%97%E5%9B%BA%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[实现列表标题标题头第一列最后一列固定 实现思路：创建三个div，布局为左中右，其中每个div中设置为上下结构（上为列表的表头，下为数据部分）左右：{overflow：hide, 宽度：固定值， 高度：根绝文档设置高度}中间：{overflow：auto, 宽度：文档宽度-左右宽度， 高度：根绝文档设置高度}js代码处理：上下滚动，左右的div scrollTop和当前滚动的divscrollTop, 左右滚动同理 代码：html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;script type="text/template7" id="container-fluid-tpl"&gt; &lt;div class="left_div"&gt; &lt;div class="left_div1"&gt; &lt;table class="left_table1"&gt; &lt;tr&gt; &lt;th&gt;基金名称&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="left_div2"&gt; &lt;table class="left_table2"&gt; &#123;&#123;#each dataLeft&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="name &#123;&#123;font&#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div class="code"&gt;&#123;&#123;code&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div"&gt; &lt;div class="data_div1"&gt; &lt;div class="data_divx"&gt; &lt;table class="data_table1"&gt; &lt;tr&gt; &lt;th&gt;认/申购费率&lt;/th&gt; &lt;th class="active"&gt;日涨幅&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1周&lt;i class="iconfont icon-arrow-down2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近1月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近3月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近6月&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;今年以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近一年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;近三年&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;th&gt;成立以来&lt;i class="iconfont icon-arrow-up2"&gt;&lt;/i&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="data_div2"&gt; &lt;table class="data_table2"&gt; &#123;&#123;#each dataCenter&#125;&#125; &lt;tr&gt; &lt;td&gt; &lt;div class="&#123;&#123;center1.status11&#125;&#125;"&gt;&#123;&#123;center1.center11&#125;&#125;&lt;/div&gt; &lt;div class="&#123;&#123;center1.status12&#125;&#125;"&gt;&#123;&#123;center1.center12&#125;&#125;&lt;/div&gt; &lt;/td&gt; &lt;td class="&#123;&#123;center2.status&#125;&#125;"&gt;&#123;&#123;center2.center2&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center3&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center4&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center5&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center6&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center7&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center8&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center9&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;center10&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="right_div"&gt; &lt;div class="right_div1"&gt; &lt;table class="right_table1"&gt; &lt;tr&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="right_div2"&gt; &lt;table class="right_table2"&gt; &#123;&#123;#each dataRight&#125;&#125; &lt;tr&gt; &lt;th&gt; &lt;div class="buy-btn"&gt;&#123;&#123;this&#125;&#125;&lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &#123;&#123;/each&#125;&#125; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135.container-fluid &#123; table &#123; width: 100%; max-width: 100%; margin-bottom: 20px; &#125; .red &#123; color: #ff0000; &#125; .green &#123; color: #1bc01b; &#125; .gray &#123; color: #a3a3a3; &#125; .tlt&#123; color: #a3a3a3; text-decoration: line-through; &#125;&#125;.left_table1 th, .data_table1 th, .right_table1 th &#123; font-size: 13px; font-weight: 500; color: #686868; text-align: center; background: #F0F1F3; padding: 7px 0;&#125;.left_table2 th, .data_table2 td, .right_table2 th &#123; word-break: break-all; font-size: 15px; font-weight: 500; text-align: center; background: #fff; border-bottom: 1px solid #efeff4; height: 90px; .fs15 &#123; font-size: 15px; &#125; .fs13 &#123; font-size: 13px; &#125; &#125;.left_div&#123; width:120px; float: left; .left_div1&#123; width: 100%; &#125; .left_div2&#123; margin-top:-20px; width: 100%; overflow: hidden; &#125; .left_table1 th &#123; text-align: left; padding-left: 16px; &#125; .left_table2 th &#123; text-align: left; padding-left: 16px; .name &#123; color: #424647; &#125; .code &#123; font-size: 13px; color: #888; &#125; &#125;&#125;.right_div&#123; width:80px; float: left; .right_div1&#123; width: 100%; &#125; .right_div2&#123; margin-top:-20px; width: 100%; // height: 72vh; overflow: hidden; &#125; .right_table2 .buy-btn&#123; font-size: 14px; color: #fff; background: #e15b54; display: inline-block; width: 60px; height: 24px; line-height: 24px; border-radius: 2px; &#125;&#125;.data_div&#123; float: left; .data_div1&#123; width: 100%; overflow: auto; &#125; .data_divx&#123; width: 900px; &#125; .data_div2&#123; margin-top:-20px; width:100%; // height:72vh; overflow: auto; -webkit-overflow-scrolling: auto; // -webkit-overflow-scrolling: touch; &#125; .data_table1&#123; width: 880px; .iconfont &#123; font-size: 12px; &#125; th.active&#123; color: #e15b54; &#125; &#125; .data_table2&#123; /**width和max-width一起写，手机浏览器打开也能固定长度**/ width: 880px; max-width: 880px; white-space:nowrap; &#125; .data_table1 th&#123; width:10%; &#125; .data_table2 td&#123; width:10%; &#125;&#125; js1234567891011121314151617181920212223242526function createTab(selector, data) &#123; var template = $$('#container-fluid-tpl').html(); var complieTemplate = Template7.compile(template); var renderTemplate = complieTemplate(data); $$(selector+' .container-fluid').html(renderTemplate); var right_div2 = document.querySelector(selector+' .data_div2'); var data_div1 = document.querySelector(selector+' .data_div1'); right_div2.onscroll = function()&#123; var right_div2_top = this.scrollTop; var right_div2_left = this.scrollLeft; document.querySelector(selector+' .left_div2').scrollTop = right_div2_top; document.querySelector(selector+' .right_div2').scrollTop = right_div2_top; document.querySelector(selector+' .data_div1').scrollLeft = right_div2_left; &#125; data_div1.onscroll = function()&#123; var data_div1_left = this.scrollLeft; document.querySelector(selector+' .data_div2').scrollLeft = data_div1_left; &#125; //设置右边div宽度 var tabHeight = $$('body').height()-$$('.navbar').height()-$$('.tab-nav').height()-$$(selector+' .data_divx').height() document.querySelector(selector+' .data_div').style.width=""+$$('body').width()-200+"px"; document.querySelector(selector+' .left_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .data_div2').style.height=tabHeight+"px"; document.querySelector(selector+' .right_div2').style.height=tabHeight+"px"; &#125; 问题&amp;总结1 苹果手机出现滚动条时会有橡皮条效果通过-webkit-overflow-scrolling设置 -webkit-overflow-scrolling: auto; // 橡皮条效果，滚动速度较慢 -webkit-overflow-scrolling: touch; // 默认效果 2 横向滚动条scroll事件频繁触发，（网页中）页面显示会有些错位。（待优化）。3 元素距离参考图片 offset- offsetWidth(包含padding、border、不包含margin) offsetHeight(同上) offsetLeft(返回元素的x坐标，相对于offsetParent；如果offsetParent为null,则返回对应的文档坐标) offsetTop(同上,返回元素的y坐标) offsetParent(返回最近的包含该元素的定位元素) client- clientWidth(不包含border、margin、滚动条) clientHeight(同上) clientLeft(相当于border-left-width,属性设置元素的左边框的宽度。) clientTop(相当于border-top-width) scroll- scrollWidth(不包含border、margin，返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）, scrollWidth的值要大于clientWidth。) scroHeight(同上) scrollLeft(可读写，获取或设置元素滚动条的位置) scrollTop(同上)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ学习1]]></title>
    <url>%2F2017%2F05%2F15%2FJQ%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[jq结构1234567(function( window, undefined ) &#123; // If there is a window object, that at least has a document property, // define jQuery and $ identifiers if ( typeof window === "object" &amp;&amp; typeof window.document === "object" ) &#123; window.jQuery = window.$ = jQuery; &#125;&#125;)( window ); 传入window对象时防止压缩时window被处理为普通变量undefined在一些浏览器中可以对undefined进行修改 JQ对象上的属性和方法1234567891011121314jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context, rootjQuery );&#125;jquery.fn = jquery.prototype = &#123; jquery: 版本, constructor: 修正指针指向问题, init: 初始化和参数管理, selector: 存储选择字符串, length: this对象的长度, toArray: 传数组, ...&#125;jQuery.fn.init.prototype = jQuery.fn; 参考文章 init方法123456789101112131415jQuery.fn = jQuery.prototype = &#123; init: function() &#123; $(""), $(null), $(undefined), $(false) $('#div1') $('.box') $('div') $('#div1 div.box') $('&lt;li&gt;') $('&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;') $(this) $(document) $(function()&#123;&#125;) $([]) $(&#123;&#125;) return jQuery.makeArray( selector, this ); &#125;&#125; 备注：1 constructor以字面量的方式定义对象，需要指定当前的constructor2 prototype, constructor, 面向对象概念理解]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习笔记]]></title>
    <url>%2F2017%2F05%2F03%2Fcanvas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简单例子123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="application/javascript"&gt; function draw() &#123; var canvas = document.getElementById("canvas"); if (canvas.getContext) &#123; var ctx = canvas.getContext("2d"); ctx.fillStyle = "rgb(200,0,0)"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = "rgba(0, 0, 200, 0.5)"; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="draw();"&gt; &lt;canvas id="canvas" width="150" height="150"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 直接可以绘制图形的方法fillRect(x, y, width, height)绘制一个填充的矩形strokeRect(x, y, width, height)绘制一个矩形的边框clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。 绘制基本图形，文本，图片，变换translate(x, y)translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。fillStyle = color设置图形的填充颜色。strokeStyle = color设置图形轮廓的颜色。globalAlpha = transparencyValue这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。lineWidth = value设置线条宽度。lineCap = type设置线条末端样式。shadowOffsetX = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowOffsetY = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowBlur = float shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。shadowColor = color shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。 绘制路径beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。closePath()闭合路径之后图形绘制命令又重新指向到上下文中。当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。stroke()通过线条来绘制图形轮廓。fill()通过填充路径的内容区域生成实心的图形moveTo(x, y)将笔触移动到指定的坐标x以及y上。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。lineTo(x, y)绘制一条从当前位置到指定x以及y位置的直线。arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。quadraticCurveTo(cp1x, cp1y, x, y)绘制贝塞尔曲线，cp1x,cp1y为控制点，x,y为结束点。rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。save()restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 推荐基于canvas小游戏 基于canvas的小游戏 详细canvas APIMDNcanvas API]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build-blog]]></title>
    <url>%2F2017%2F05%2F03%2Fbuild-blog%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start导入hexo1$ npm install -g hexo-cli --registry=https://registry.npm.taobao.org 初始化项目1$ hexo init Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites123456789$ hexo deploy// 报错:ERROR Deployer not found: githubnpm install hexo-deployer-git --savedeploy: type: git // 或者github repository: git@github.com:lvSally/lvSally.github.io.git branch: master Hexo的版本控制与持续集成参考文章思路：新建一个项目，每次代码更新的时候，通过CI生成新的github.io文件问题： 由于我使用next的主题文件，CI后的css、js/src、images、vendors文件夹全部删除了，我通过的是删除next文件提交，然后再添加的方法解决的，原因不太清楚，很神奇，哭.. 其它1 使用hexo new page tags/categories 创建分类或标签2 在themes _config.yml 控制主体显示3 themes -&gt; _config.yml -&gt; baidu_analytics 添加百度统计id可添加百度统计功能4 themes -&gt; _config.yml -&gt; avatar 设置头像5 next第三方服务集成6 网易云跟帖 悲剧的是类似github.io的子域名基本信息填写不能通过7 Disqus,最终选择了Disqus，缺点是需要翻墙，使用Disqus比较简单，注册一个账号，在主题的设置文件中添加以下shortname即可。More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
